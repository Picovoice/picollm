export declare const forwardShuffleXShaderSource = "\nstruct argsStruct {\n  n: u32,\n  shape1: u32,\n  x_offset: u32,\n  indices_offset: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> indices: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n || global_id.y >= args.shape1) {\n    return;\n  } \n\n  let b = global_id.x;\n  let i = global_id.y;\n      \n  let c = i / 8u;\n  let j = i % 8u;\n  y[((c * args.n) + b) * 8 + j] = x[args.x_offset + (b * args.shape1) + indices[args.indices_offset + i]];\n}\n\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main_empty() {}\n\n";
export declare const forwardSingleReduceYShaderSource = "\nstruct argsStruct {\n  nvr: u32,\n  nbc: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read_write> y: array<vec4<f32>>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {   \n  if (global_id.x > args.nvr) {\n    return;\n  }\n\n  let x_start = global_id.x * args.nbc;\n  var sum: vec4<f32> = vec4(0.0, 0.0, 0.0, 0.0);\n  for (var i = 0u; i < args.nbc; i++) {\n    sum += x[x_start + i];    \n  }\n  y[global_id.x] += sum;\n}\n\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main_empty() {}\n";
export declare const forwardShuffleYShaderSource = "\nstruct argsStruct {\n  n: u32,\n  shape0: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    if (global_id.x >= args.n || global_id.y >= args.shape0) {\n      return;\n    } \n    \n    let b = global_id.x;\n    let i = global_id.y;\n        \n    let r = i / 16u;\n    let j = i % 16u;\n    y[(b * args.shape0) + (r * 16) + j] = x[(((r * args.n) + b) * 16) + j];\n}\n\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main_empty() {}\n";
export declare const addBiasShaderSource = "\nstruct argsStruct {\n  dimension: u32\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> bias: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> y: array<f32>;\n\n\n\nconst exponents: array<f32, 32> = array(\n  2.9103830456733704e-11, \n  5.820766091346741e-11, \n  1.1641532182693481e-10, \n  2.3283064365386963e-10,\n  4.656612873077393e-10, \n  9.313225746154785e-10, \n  1.862645149230957e-09, \n  3.725290298461914e-09,\n  7.450580596923828e-09, \n  1.4901161193847656e-08, \n  2.9802322387695312e-08, \n  5.960464477539063e-08,\n  1.1920928955078125e-07, \n  2.384185791015625e-07, \n  4.76837158203125e-07, \n  9.5367431640625e-07,\n  1.9073486328125e-06, \n  3.814697265625e-06, \n  7.62939453125e-06, \n  1.52587890625e-05, \n  3.0517578125e-05,\n  6.103515625e-05, \n  0.0001220703125, \n  0.000244140625, \n  0.00048828125, \n  0.0009765625, \n  0.001953125, \n  0.00390625,\n  0.0078125, \n  0.015625, \n  0.03125, \n  0.0625);\n\nfn from_fp510(x: u32) -> f32 {\n    let exponent = f32(exponents[extractBits(x, 10u, 5u)]);        \n    let fractional = f32(extractBits(x, 0u, 10u));        \n    let abs = exponent * fractional;\n    return abs * (1.0 - (2.0 * f32(extractBits(x, 15u, 1u))));\n}\n\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {  \n  y[(global_id.x * args.dimension) + global_id.y] += bias[global_id.y];\n}\n\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main_empty() {}\n";
export declare const forwardSingleShaderSources: {
    [bitDepth: number]: string;
};
export declare const forwardSingleShaderNames: {
    [bitDepth: number]: string;
};
export declare const forwardShaderSources: {
    [bitDepth: number]: string;
};
export declare const forwardShaderNames: {
    [bitDepth: number]: string;
};
export declare const forwardShuffleXShaderName = "pv_picollm_weight_block_mixed_16x8_forward_shuffle_x_shader";
export declare const forwardShuffleYShaderName = "pv_picollm_weight_block_mixed_16x8_forward_shuffle_y_shader";
export declare const addBiasShaderName = "pv_picollm_weight_block_mixed_16x8_add_bias_shader";
export declare const forwardSingleReduceYShaderName = "pv_picollm_weight_block_mixed_16x8_forward_single_reduce_y_shader";
//# sourceMappingURL=pv_picollm_weight_block_mixed_16x8_forward.d.ts.map