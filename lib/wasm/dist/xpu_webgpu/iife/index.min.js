var XpuWebgpu=function(){"use strict";function e(e,t,r,n,a,i,u){try{var o=e[i](u),s=o.value}catch(e){return void r(e)}o.done?t(s):Promise.resolve(s).then(n,a)}function t(t){return function(){var r=this,n=arguments;return new Promise((function(a,i){var u=t.apply(r,n);function o(t){e(u,a,i,o,s,"next",t)}function s(t){e(u,a,i,o,s,"throw",t)}o(void 0)}))}}function r(e){return r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r(e)}function n(e){var t=function(e,t){if("object"!=r(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var a=n.call(e,t||"default");if("object"!=r(a))return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==r(t)?t:String(t)}function a(e,t,r){return(t=n(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var u={exports:{}},o={exports:{}};!function(e){function t(r){return e.exports=t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},e.exports.__esModule=!0,e.exports.default=e.exports,t(r)}e.exports=t,e.exports.__esModule=!0,e.exports.default=e.exports}(o);var s=o.exports;!function(e){var t=s.default;function r(){e.exports=r=function(){return a},e.exports.__esModule=!0,e.exports.default=e.exports;var n,a={},i=Object.prototype,u=i.hasOwnProperty,o=Object.defineProperty||function(e,t,r){e[t]=r.value},s="function"==typeof Symbol?Symbol:{},c=s.iterator||"@@iterator",l=s.asyncIterator||"@@asyncIterator",_=s.toStringTag||"@@toStringTag";function d(e,t,r){return Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{d({},"")}catch(n){d=function(e,t,r){return e[t]=r}}function f(e,t,r,n){var a=t&&t.prototype instanceof m?t:m,i=Object.create(a.prototype),u=new O(n||[]);return o(i,"_invoke",{value:z(e,r,u)}),i}function b(e,t,r){try{return{type:"normal",arg:e.call(t,r)}}catch(e){return{type:"throw",arg:e}}}a.wrap=f;var p="suspendedStart",g="suspendedYield",v="executing",x="completed",k={};function m(){}function h(){}function y(){}var B={};d(B,c,(function(){return this}));var w=Object.getPrototypeOf,P=w&&w(w(G([])));P&&P!==i&&u.call(P,c)&&(B=P);var S=y.prototype=m.prototype=Object.create(B);function E(e){["next","throw","return"].forEach((function(t){d(e,t,(function(e){return this._invoke(t,e)}))}))}function U(e,r){function n(a,i,o,s){var c=b(e[a],e,i);if("throw"!==c.type){var l=c.arg,_=l.value;return _&&"object"==t(_)&&u.call(_,"__await")?r.resolve(_.__await).then((function(e){n("next",e,o,s)}),(function(e){n("throw",e,o,s)})):r.resolve(_).then((function(e){l.value=e,o(l)}),(function(e){return n("throw",e,o,s)}))}s(c.arg)}var a;o(this,"_invoke",{value:function(e,t){function i(){return new r((function(r,a){n(e,t,r,a)}))}return a=a?a.then(i,i):i()}})}function z(e,t,r){var a=p;return function(i,u){if(a===v)throw new Error("Generator is already running");if(a===x){if("throw"===i)throw u;return{value:n,done:!0}}for(r.method=i,r.arg=u;;){var o=r.delegate;if(o){var s=j(o,r);if(s){if(s===k)continue;return s}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(a===p)throw a=x,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);a=v;var c=b(e,t,r);if("normal"===c.type){if(a=r.done?x:g,c.arg===k)continue;return{value:c.arg,done:r.done}}"throw"===c.type&&(a=x,r.method="throw",r.arg=c.arg)}}}function j(e,t){var r=t.method,a=e.iterator[r];if(a===n)return t.delegate=null,"throw"===r&&e.iterator.return&&(t.method="return",t.arg=n,j(e,t),"throw"===t.method)||"return"!==r&&(t.method="throw",t.arg=new TypeError("The iterator does not provide a '"+r+"' method")),k;var i=b(a,e.iterator,t.arg);if("throw"===i.type)return t.method="throw",t.arg=i.arg,t.delegate=null,k;var u=i.arg;return u?u.done?(t[e.resultName]=u.value,t.next=e.nextLoc,"return"!==t.method&&(t.method="next",t.arg=n),t.delegate=null,k):u:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,k)}function M(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function C(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function O(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(M,this),this.reset(!0)}function G(e){if(e||""===e){var r=e[c];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var a=-1,i=function t(){for(;++a<e.length;)if(u.call(e,a))return t.value=e[a],t.done=!1,t;return t.value=n,t.done=!0,t};return i.next=i}}throw new TypeError(t(e)+" is not iterable")}return h.prototype=y,o(S,"constructor",{value:y,configurable:!0}),o(y,"constructor",{value:h,configurable:!0}),h.displayName=d(y,_,"GeneratorFunction"),a.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===h||"GeneratorFunction"===(t.displayName||t.name))},a.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,y):(e.__proto__=y,d(e,_,"GeneratorFunction")),e.prototype=Object.create(S),e},a.awrap=function(e){return{__await:e}},E(U.prototype),d(U.prototype,l,(function(){return this})),a.AsyncIterator=U,a.async=function(e,t,r,n,i){void 0===i&&(i=Promise);var u=new U(f(e,t,r,n),i);return a.isGeneratorFunction(t)?u:u.next().then((function(e){return e.done?e.value:u.next()}))},E(S),d(S,_,"Generator"),d(S,c,(function(){return this})),d(S,"toString",(function(){return"[object Generator]"})),a.keys=function(e){var t=Object(e),r=[];for(var n in t)r.push(n);return r.reverse(),function e(){for(;r.length;){var n=r.pop();if(n in t)return e.value=n,e.done=!1,e}return e.done=!0,e}},a.values=G,O.prototype={constructor:O,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=n,this.done=!1,this.delegate=null,this.method="next",this.arg=n,this.tryEntries.forEach(C),!e)for(var t in this)"t"===t.charAt(0)&&u.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=n)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var t=this;function r(r,a){return o.type="throw",o.arg=e,t.next=r,a&&(t.method="next",t.arg=n),!!a}for(var a=this.tryEntries.length-1;a>=0;--a){var i=this.tryEntries[a],o=i.completion;if("root"===i.tryLoc)return r("end");if(i.tryLoc<=this.prev){var s=u.call(i,"catchLoc"),c=u.call(i,"finallyLoc");if(s&&c){if(this.prev<i.catchLoc)return r(i.catchLoc,!0);if(this.prev<i.finallyLoc)return r(i.finallyLoc)}else if(s){if(this.prev<i.catchLoc)return r(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return r(i.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&u.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var a=n;break}}a&&("break"===e||"continue"===e)&&a.tryLoc<=t&&t<=a.finallyLoc&&(a=null);var i=a?a.completion:{};return i.type=e,i.arg=t,a?(this.method="next",this.next=a.finallyLoc,k):this.complete(i)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),k},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),C(r),k}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if("throw"===n.type){var a=n.arg;C(r)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(e,t,r){return this.delegate={iterator:G(e),resultName:t,nextLoc:r},"next"===this.method&&(this.arg=n),k}},a}e.exports=r,e.exports.__esModule=!0,e.exports.default=e.exports}(u);var c=(0,u.exports)(),l=c;try{regeneratorRuntime=c}catch(e){"object"==typeof globalThis?globalThis.regeneratorRuntime=c:Function("r","regeneratorRuntime = r")(c)}var _=i(l);const d={"Amazon Silk":"amazon_silk","Android Browser":"android",Bada:"bada",BlackBerry:"blackberry",Chrome:"chrome",Chromium:"chromium",Electron:"electron",Epiphany:"epiphany",Firefox:"firefox",Focus:"focus",Generic:"generic","Google Search":"google_search",Googlebot:"googlebot","Internet Explorer":"ie","K-Meleon":"k_meleon",Maxthon:"maxthon","Microsoft Edge":"edge","MZ Browser":"mz","NAVER Whale Browser":"naver",Opera:"opera","Opera Coast":"opera_coast",PhantomJS:"phantomjs",Puffin:"puffin",QupZilla:"qupzilla",QQ:"qq",QQLite:"qqlite",Safari:"safari",Sailfish:"sailfish","Samsung Internet for Android":"samsung_internet",SeaMonkey:"seamonkey",Sleipnir:"sleipnir",Swing:"swing",Tizen:"tizen","UC Browser":"uc",Vivaldi:"vivaldi","WebOS Browser":"webos",WeChat:"wechat","Yandex Browser":"yandex",Roku:"roku"},f={amazon_silk:"Amazon Silk",android:"Android Browser",bada:"Bada",blackberry:"BlackBerry",chrome:"Chrome",chromium:"Chromium",electron:"Electron",epiphany:"Epiphany",firefox:"Firefox",focus:"Focus",generic:"Generic",googlebot:"Googlebot",google_search:"Google Search",ie:"Internet Explorer",k_meleon:"K-Meleon",maxthon:"Maxthon",edge:"Microsoft Edge",mz:"MZ Browser",naver:"NAVER Whale Browser",opera:"Opera",opera_coast:"Opera Coast",phantomjs:"PhantomJS",puffin:"Puffin",qupzilla:"QupZilla",qq:"QQ Browser",qqlite:"QQ Browser Lite",safari:"Safari",sailfish:"Sailfish",samsung_internet:"Samsung Internet for Android",seamonkey:"SeaMonkey",sleipnir:"Sleipnir",swing:"Swing",tizen:"Tizen",uc:"UC Browser",vivaldi:"Vivaldi",webos:"WebOS Browser",wechat:"WeChat",yandex:"Yandex Browser"},b={tablet:"tablet",mobile:"mobile",desktop:"desktop",tv:"tv"},p={WindowsPhone:"Windows Phone",Windows:"Windows",MacOS:"macOS",iOS:"iOS",Android:"Android",WebOS:"WebOS",BlackBerry:"BlackBerry",Bada:"Bada",Tizen:"Tizen",Linux:"Linux",ChromeOS:"Chrome OS",PlayStation4:"PlayStation 4",Roku:"Roku"},g={EdgeHTML:"EdgeHTML",Blink:"Blink",Trident:"Trident",Presto:"Presto",Gecko:"Gecko",WebKit:"WebKit"};class v{static getFirstMatch(e,t){const r=t.match(e);return r&&r.length>0&&r[1]||""}static getSecondMatch(e,t){const r=t.match(e);return r&&r.length>1&&r[2]||""}static matchAndReturnConst(e,t,r){if(e.test(t))return r}static getWindowsVersionName(e){switch(e){case"NT":return"NT";case"XP":case"NT 5.1":return"XP";case"NT 5.0":return"2000";case"NT 5.2":return"2003";case"NT 6.0":return"Vista";case"NT 6.1":return"7";case"NT 6.2":return"8";case"NT 6.3":return"8.1";case"NT 10.0":return"10";default:return}}static getMacOSVersionName(e){const t=e.split(".").splice(0,2).map((e=>parseInt(e,10)||0));if(t.push(0),10===t[0])switch(t[1]){case 5:return"Leopard";case 6:return"Snow Leopard";case 7:return"Lion";case 8:return"Mountain Lion";case 9:return"Mavericks";case 10:return"Yosemite";case 11:return"El Capitan";case 12:return"Sierra";case 13:return"High Sierra";case 14:return"Mojave";case 15:return"Catalina";default:return}}static getAndroidVersionName(e){const t=e.split(".").splice(0,2).map((e=>parseInt(e,10)||0));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?"Cupcake":1===t[0]&&t[1]>=6?"Donut":2===t[0]&&t[1]<2?"Eclair":2===t[0]&&2===t[1]?"Froyo":2===t[0]&&t[1]>2?"Gingerbread":3===t[0]?"Honeycomb":4===t[0]&&t[1]<1?"Ice Cream Sandwich":4===t[0]&&t[1]<4?"Jelly Bean":4===t[0]&&t[1]>=4?"KitKat":5===t[0]?"Lollipop":6===t[0]?"Marshmallow":7===t[0]?"Nougat":8===t[0]?"Oreo":9===t[0]?"Pie":void 0}static getVersionPrecision(e){return e.split(".").length}static compareVersions(e,t,r=!1){const n=v.getVersionPrecision(e),a=v.getVersionPrecision(t);let i=Math.max(n,a),u=0;const o=v.map([e,t],(e=>{const t=i-v.getVersionPrecision(e),r=e+new Array(t+1).join(".0");return v.map(r.split("."),(e=>new Array(20-e.length).join("0")+e)).reverse()}));for(r&&(u=i-Math.min(n,a)),i-=1;i>=u;){if(o[0][i]>o[1][i])return 1;if(o[0][i]===o[1][i]){if(i===u)return 0;i-=1}else if(o[0][i]<o[1][i])return-1}}static map(e,t){const r=[];let n;if(Array.prototype.map)return Array.prototype.map.call(e,t);for(n=0;n<e.length;n+=1)r.push(t(e[n]));return r}static find(e,t){let r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){const n=e[r];if(t(n,r))return n}}static assign(e,...t){const r=e;let n,a;if(Object.assign)return Object.assign(e,...t);for(n=0,a=t.length;n<a;n+=1){const e=t[n];if("object"==typeof e&&null!==e){Object.keys(e).forEach((t=>{r[t]=e[t]}))}}return e}static getBrowserAlias(e){return d[e]}static getBrowserTypeByAlias(e){return f[e]||""}}const x=/version\/(\d+(\.?_?\d+)+)/i,k=[{test:[/googlebot/i],describe(e){const t={name:"Googlebot"},r=v.getFirstMatch(/googlebot\/(\d+(\.\d+))/i,e)||v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/opera/i],describe(e){const t={name:"Opera"},r=v.getFirstMatch(x,e)||v.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\/|opios/i],describe(e){const t={name:"Opera"},r=v.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i,e)||v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe(e){const t={name:"Samsung Internet for Android"},r=v.getFirstMatch(x,e)||v.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe(e){const t={name:"NAVER Whale Browser"},r=v.getFirstMatch(x,e)||v.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe(e){const t={name:"MZ Browser"},r=v.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,e)||v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/focus/i],describe(e){const t={name:"Focus"},r=v.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i,e)||v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/swing/i],describe(e){const t={name:"Swing"},r=v.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i,e)||v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/coast/i],describe(e){const t={name:"Opera Coast"},r=v.getFirstMatch(x,e)||v.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\/\d+(?:.?_?\d+)+/i],describe(e){const t={name:"Opera Touch"},r=v.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i,e)||v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe(e){const t={name:"Yandex Browser"},r=v.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,e)||v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe(e){const t={name:"UC Browser"},r=v.getFirstMatch(x,e)||v.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe(e){const t={name:"Maxthon"},r=v.getFirstMatch(x,e)||v.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe(e){const t={name:"Epiphany"},r=v.getFirstMatch(x,e)||v.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe(e){const t={name:"Puffin"},r=v.getFirstMatch(x,e)||v.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe(e){const t={name:"Sleipnir"},r=v.getFirstMatch(x,e)||v.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe(e){const t={name:"K-Meleon"},r=v.getFirstMatch(x,e)||v.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe(e){const t={name:"WeChat"},r=v.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,e)||v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe(e){const t={name:/qqbrowserlite/i.test(e)?"QQ Browser Lite":"QQ Browser"},r=v.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,e)||v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe(e){const t={name:"Internet Explorer"},r=v.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\sedg\//i],describe(e){const t={name:"Microsoft Edge"},r=v.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe(e){const t={name:"Microsoft Edge"},r=v.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe(e){const t={name:"Vivaldi"},r=v.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe(e){const t={name:"SeaMonkey"},r=v.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe(e){const t={name:"Sailfish"},r=v.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe(e){const t={name:"Amazon Silk"},r=v.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe(e){const t={name:"PhantomJS"},r=v.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe(e){const t={name:"SlimerJS"},r=v.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe(e){const t={name:"BlackBerry"},r=v.getFirstMatch(x,e)||v.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe(e){const t={name:"WebOS Browser"},r=v.getFirstMatch(x,e)||v.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe(e){const t={name:"Bada"},r=v.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe(e){const t={name:"Tizen"},r=v.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,e)||v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe(e){const t={name:"QupZilla"},r=v.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,e)||v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe(e){const t={name:"Firefox"},r=v.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe(e){const t={name:"Electron"},r=v.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe(e){const t={name:"Miui"},r=v.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe(e){const t={name:"Chromium"},r=v.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,e)||v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe(e){const t={name:"Chrome"},r=v.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe(e){const t={name:"Google Search"},r=v.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test(e){const t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe(e){const t={name:"Android Browser"},r=v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe(e){const t={name:"PlayStation 4"},r=v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe(e){const t={name:"Safari"},r=v.getFirstMatch(x,e);return r&&(t.version=r),t}},{test:[/.*/i],describe(e){const t=-1!==e.search("\\(")?/^(.*)\/(.*)[ \t]\((.*)/:/^(.*)\/(.*) /;return{name:v.getFirstMatch(t,e),version:v.getSecondMatch(t,e)}}}];var m=[{test:[/Roku\/DVP/],describe(e){const t=v.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i,e);return{name:p.Roku,version:t}}},{test:[/windows phone/i],describe(e){const t=v.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i,e);return{name:p.WindowsPhone,version:t}}},{test:[/windows /i],describe(e){const t=v.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i,e),r=v.getWindowsVersionName(t);return{name:p.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe(e){const t={name:p.iOS},r=v.getSecondMatch(/(Version\/)(\d[\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe(e){const t=v.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i,e).replace(/[_\s]/g,"."),r=v.getMacOSVersionName(t),n={name:p.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe(e){const t=v.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i,e).replace(/[_\s]/g,".");return{name:p.iOS,version:t}}},{test(e){const t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe(e){const t=v.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i,e),r=v.getAndroidVersionName(t),n={name:p.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe(e){const t=v.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,e),r={name:p.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe(e){const t=v.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i,e)||v.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i,e)||v.getFirstMatch(/\bbb(\d+)/i,e);return{name:p.BlackBerry,version:t}}},{test:[/bada/i],describe(e){const t=v.getFirstMatch(/bada\/(\d+(\.\d+)*)/i,e);return{name:p.Bada,version:t}}},{test:[/tizen/i],describe(e){const t=v.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i,e);return{name:p.Tizen,version:t}}},{test:[/linux/i],describe:()=>({name:p.Linux})},{test:[/CrOS/],describe:()=>({name:p.ChromeOS})},{test:[/PlayStation 4/],describe(e){const t=v.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i,e);return{name:p.PlayStation4,version:t}}}],h=[{test:[/googlebot/i],describe:()=>({type:"bot",vendor:"Google"})},{test:[/huawei/i],describe(e){const t=v.getFirstMatch(/(can-l01)/i,e)&&"Nova",r={type:b.mobile,vendor:"Huawei"};return t&&(r.model=t),r}},{test:[/nexus\s*(?:7|8|9|10).*/i],describe:()=>({type:b.tablet,vendor:"Nexus"})},{test:[/ipad/i],describe:()=>({type:b.tablet,vendor:"Apple",model:"iPad"})},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:()=>({type:b.tablet,vendor:"Apple",model:"iPad"})},{test:[/kftt build/i],describe:()=>({type:b.tablet,vendor:"Amazon",model:"Kindle Fire HD 7"})},{test:[/silk/i],describe:()=>({type:b.tablet,vendor:"Amazon"})},{test:[/tablet(?! pc)/i],describe:()=>({type:b.tablet})},{test(e){const t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe(e){const t=v.getFirstMatch(/(ipod|iphone)/i,e);return{type:b.mobile,vendor:"Apple",model:t}}},{test:[/nexus\s*[0-6].*/i,/galaxy nexus/i],describe:()=>({type:b.mobile,vendor:"Nexus"})},{test:[/[^-]mobi/i],describe:()=>({type:b.mobile})},{test:e=>"blackberry"===e.getBrowserName(!0),describe:()=>({type:b.mobile,vendor:"BlackBerry"})},{test:e=>"bada"===e.getBrowserName(!0),describe:()=>({type:b.mobile})},{test:e=>"windows phone"===e.getBrowserName(),describe:()=>({type:b.mobile,vendor:"Microsoft"})},{test(e){const t=Number(String(e.getOSVersion()).split(".")[0]);return"android"===e.getOSName(!0)&&t>=3},describe:()=>({type:b.tablet})},{test:e=>"android"===e.getOSName(!0),describe:()=>({type:b.mobile})},{test:e=>"macos"===e.getOSName(!0),describe:()=>({type:b.desktop,vendor:"Apple"})},{test:e=>"windows"===e.getOSName(!0),describe:()=>({type:b.desktop})},{test:e=>"linux"===e.getOSName(!0),describe:()=>({type:b.desktop})},{test:e=>"playstation 4"===e.getOSName(!0),describe:()=>({type:b.tv})},{test:e=>"roku"===e.getOSName(!0),describe:()=>({type:b.tv})}],y=[{test:e=>"microsoft edge"===e.getBrowserName(!0),describe(e){if(/\sedg\//i.test(e))return{name:g.Blink};const t=v.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i,e);return{name:g.EdgeHTML,version:t}}},{test:[/trident/i],describe(e){const t={name:g.Trident},r=v.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:e=>e.test(/presto/i),describe(e){const t={name:g.Presto},r=v.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test(e){const t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe(e){const t={name:g.Gecko},r=v.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\/537\.36/i],describe:()=>({name:g.Blink})},{test:[/(apple)?webkit/i],describe(e){const t={name:g.WebKit},r=v.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}}];class B{constructor(e,t=!1){if(null==e||""===e)throw new Error("UserAgent parameter can't be empty");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}getUA(){return this._ua}test(e){return e.test(this._ua)}parseBrowser(){this.parsedResult.browser={};const e=v.find(k,(e=>{if("function"==typeof e.test)return e.test(this);if(e.test instanceof Array)return e.test.some((e=>this.test(e)));throw new Error("Browser's test function is not valid")}));return e&&(this.parsedResult.browser=e.describe(this.getUA())),this.parsedResult.browser}getBrowser(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()}getBrowserName(e){return e?String(this.getBrowser().name).toLowerCase()||"":this.getBrowser().name||""}getBrowserVersion(){return this.getBrowser().version}getOS(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()}parseOS(){this.parsedResult.os={};const e=v.find(m,(e=>{if("function"==typeof e.test)return e.test(this);if(e.test instanceof Array)return e.test.some((e=>this.test(e)));throw new Error("Browser's test function is not valid")}));return e&&(this.parsedResult.os=e.describe(this.getUA())),this.parsedResult.os}getOSName(e){const{name:t}=this.getOS();return e?String(t).toLowerCase()||"":t||""}getOSVersion(){return this.getOS().version}getPlatform(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()}getPlatformType(e=!1){const{type:t}=this.getPlatform();return e?String(t).toLowerCase()||"":t||""}parsePlatform(){this.parsedResult.platform={};const e=v.find(h,(e=>{if("function"==typeof e.test)return e.test(this);if(e.test instanceof Array)return e.test.some((e=>this.test(e)));throw new Error("Browser's test function is not valid")}));return e&&(this.parsedResult.platform=e.describe(this.getUA())),this.parsedResult.platform}getEngine(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()}getEngineName(e){return e?String(this.getEngine().name).toLowerCase()||"":this.getEngine().name||""}parseEngine(){this.parsedResult.engine={};const e=v.find(y,(e=>{if("function"==typeof e.test)return e.test(this);if(e.test instanceof Array)return e.test.some((e=>this.test(e)));throw new Error("Browser's test function is not valid")}));return e&&(this.parsedResult.engine=e.describe(this.getUA())),this.parsedResult.engine}parse(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this}getResult(){return v.assign({},this.parsedResult)}satisfies(e){const t={};let r=0;const n={};let a=0;if(Object.keys(e).forEach((i=>{const u=e[i];"string"==typeof u?(n[i]=u,a+=1):"object"==typeof u&&(t[i]=u,r+=1)})),r>0){const e=Object.keys(t),r=v.find(e,(e=>this.isOS(e)));if(r){const e=this.satisfies(t[r]);if(void 0!==e)return e}const n=v.find(e,(e=>this.isPlatform(e)));if(n){const e=this.satisfies(t[n]);if(void 0!==e)return e}}if(a>0){const e=Object.keys(n),t=v.find(e,(e=>this.isBrowser(e,!0)));if(void 0!==t)return this.compareVersion(n[t])}}isBrowser(e,t=!1){const r=this.getBrowserName().toLowerCase();let n=e.toLowerCase();const a=v.getBrowserTypeByAlias(n);return t&&a&&(n=a.toLowerCase()),n===r}compareVersion(e){let t=[0],r=e,n=!1;const a=this.getBrowserVersion();if("string"==typeof a)return">"===e[0]||"<"===e[0]?(r=e.substr(1),"="===e[1]?(n=!0,r=e.substr(2)):t=[],">"===e[0]?t.push(1):t.push(-1)):"="===e[0]?r=e.substr(1):"~"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(v.compareVersions(a,r,n))>-1}isOS(e){return this.getOSName(!0)===String(e).toLowerCase()}isPlatform(e){return this.getPlatformType(!0)===String(e).toLowerCase()}isEngine(e){return this.getEngineName(!0)===String(e).toLowerCase()}is(e,t=!1){return this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)}some(e=[]){return e.some((e=>this.is(e)))}}
/*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   */class w{static getParser(e,t=!1){if("string"!=typeof e)throw new Error("UserAgent should be a string");return new B(e,t)}static parse(e){return new B(e).getResult()}static get BROWSER_MAP(){return f}static get ENGINE_MAP(){return g}static get OS_MAP(){return p}static get PLATFORMS_MAP(){return b}}var P={exports:{}},S={exports:{}};!function(e){function t(r){return e.exports=t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},e.exports.__esModule=!0,e.exports.default=e.exports,t(r)}e.exports=t,e.exports.__esModule=!0,e.exports.default=e.exports}(S);var E=S.exports;!function(e){var t=E.default;function r(){e.exports=r=function(){return a},e.exports.__esModule=!0,e.exports.default=e.exports;var n,a={},i=Object.prototype,u=i.hasOwnProperty,o=Object.defineProperty||function(e,t,r){e[t]=r.value},s="function"==typeof Symbol?Symbol:{},c=s.iterator||"@@iterator",l=s.asyncIterator||"@@asyncIterator",_=s.toStringTag||"@@toStringTag";function d(e,t,r){return Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{d({},"")}catch(n){d=function(e,t,r){return e[t]=r}}function f(e,t,r,n){var a=t&&t.prototype instanceof m?t:m,i=Object.create(a.prototype),u=new O(n||[]);return o(i,"_invoke",{value:z(e,r,u)}),i}function b(e,t,r){try{return{type:"normal",arg:e.call(t,r)}}catch(e){return{type:"throw",arg:e}}}a.wrap=f;var p="suspendedStart",g="suspendedYield",v="executing",x="completed",k={};function m(){}function h(){}function y(){}var B={};d(B,c,(function(){return this}));var w=Object.getPrototypeOf,P=w&&w(w(G([])));P&&P!==i&&u.call(P,c)&&(B=P);var S=y.prototype=m.prototype=Object.create(B);function E(e){["next","throw","return"].forEach((function(t){d(e,t,(function(e){return this._invoke(t,e)}))}))}function U(e,r){function n(a,i,o,s){var c=b(e[a],e,i);if("throw"!==c.type){var l=c.arg,_=l.value;return _&&"object"==t(_)&&u.call(_,"__await")?r.resolve(_.__await).then((function(e){n("next",e,o,s)}),(function(e){n("throw",e,o,s)})):r.resolve(_).then((function(e){l.value=e,o(l)}),(function(e){return n("throw",e,o,s)}))}s(c.arg)}var a;o(this,"_invoke",{value:function(e,t){function i(){return new r((function(r,a){n(e,t,r,a)}))}return a=a?a.then(i,i):i()}})}function z(e,t,r){var a=p;return function(i,u){if(a===v)throw new Error("Generator is already running");if(a===x){if("throw"===i)throw u;return{value:n,done:!0}}for(r.method=i,r.arg=u;;){var o=r.delegate;if(o){var s=j(o,r);if(s){if(s===k)continue;return s}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(a===p)throw a=x,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);a=v;var c=b(e,t,r);if("normal"===c.type){if(a=r.done?x:g,c.arg===k)continue;return{value:c.arg,done:r.done}}"throw"===c.type&&(a=x,r.method="throw",r.arg=c.arg)}}}function j(e,t){var r=t.method,a=e.iterator[r];if(a===n)return t.delegate=null,"throw"===r&&e.iterator.return&&(t.method="return",t.arg=n,j(e,t),"throw"===t.method)||"return"!==r&&(t.method="throw",t.arg=new TypeError("The iterator does not provide a '"+r+"' method")),k;var i=b(a,e.iterator,t.arg);if("throw"===i.type)return t.method="throw",t.arg=i.arg,t.delegate=null,k;var u=i.arg;return u?u.done?(t[e.resultName]=u.value,t.next=e.nextLoc,"return"!==t.method&&(t.method="next",t.arg=n),t.delegate=null,k):u:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,k)}function M(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function C(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function O(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(M,this),this.reset(!0)}function G(e){if(e||""===e){var r=e[c];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var a=-1,i=function t(){for(;++a<e.length;)if(u.call(e,a))return t.value=e[a],t.done=!1,t;return t.value=n,t.done=!0,t};return i.next=i}}throw new TypeError(t(e)+" is not iterable")}return h.prototype=y,o(S,"constructor",{value:y,configurable:!0}),o(y,"constructor",{value:h,configurable:!0}),h.displayName=d(y,_,"GeneratorFunction"),a.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===h||"GeneratorFunction"===(t.displayName||t.name))},a.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,y):(e.__proto__=y,d(e,_,"GeneratorFunction")),e.prototype=Object.create(S),e},a.awrap=function(e){return{__await:e}},E(U.prototype),d(U.prototype,l,(function(){return this})),a.AsyncIterator=U,a.async=function(e,t,r,n,i){void 0===i&&(i=Promise);var u=new U(f(e,t,r,n),i);return a.isGeneratorFunction(t)?u:u.next().then((function(e){return e.done?e.value:u.next()}))},E(S),d(S,_,"Generator"),d(S,c,(function(){return this})),d(S,"toString",(function(){return"[object Generator]"})),a.keys=function(e){var t=Object(e),r=[];for(var n in t)r.push(n);return r.reverse(),function e(){for(;r.length;){var n=r.pop();if(n in t)return e.value=n,e.done=!1,e}return e.done=!0,e}},a.values=G,O.prototype={constructor:O,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=n,this.done=!1,this.delegate=null,this.method="next",this.arg=n,this.tryEntries.forEach(C),!e)for(var t in this)"t"===t.charAt(0)&&u.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=n)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var t=this;function r(r,a){return o.type="throw",o.arg=e,t.next=r,a&&(t.method="next",t.arg=n),!!a}for(var a=this.tryEntries.length-1;a>=0;--a){var i=this.tryEntries[a],o=i.completion;if("root"===i.tryLoc)return r("end");if(i.tryLoc<=this.prev){var s=u.call(i,"catchLoc"),c=u.call(i,"finallyLoc");if(s&&c){if(this.prev<i.catchLoc)return r(i.catchLoc,!0);if(this.prev<i.finallyLoc)return r(i.finallyLoc)}else if(s){if(this.prev<i.catchLoc)return r(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return r(i.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&u.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var a=n;break}}a&&("break"===e||"continue"===e)&&a.tryLoc<=t&&t<=a.finallyLoc&&(a=null);var i=a?a.completion:{};return i.type=e,i.arg=t,a?(this.method="next",this.next=a.finallyLoc,k):this.complete(i)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),k},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),C(r),k}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if("throw"===n.type){var a=n.arg;C(r)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(e,t,r){return this.delegate={iterator:G(e),resultName:t,nextLoc:r},"next"===this.method&&(this.arg=n),k}},a}e.exports=r,e.exports.__esModule=!0,e.exports.default=e.exports}(P);var U=(0,P.exports)();try{regeneratorRuntime=U}catch(e){"object"==typeof globalThis?globalThis.regeneratorRuntime=U:Function("r","regeneratorRuntime = r")(U)}function z(e){return z="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},z(e)}function j(e){var t=function(e,t){if("object"!==z(e)||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!==z(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"===z(t)?t:String(t)}function M(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,j(n.key),n)}}function C(e){return e<0?e>>>0:e}function O(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function G(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=r){var n,a,i,u,o=[],s=!0,c=!1;try{if(i=(r=r.call(e)).next,0===t){if(Object(r)!==r)return;s=!1}else for(;!(s=(n=i.call(r)).done)&&(o.push(n.value),o.length!==t);s=!0);}catch(e){c=!0,a=e}finally{try{if(!s&&null!=r.return&&(u=r.return(),Object(u)!==u))return}finally{if(c)throw a}}return o}}(e,t)||function(e,t){if(e){if("string"==typeof e)return O(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?O(e,t):void 0}}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function T(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,n(a.key),a)}}function L(e,t){var r="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!r){if(Array.isArray(e)||(r=function(e,t){if(!e)return;if("string"==typeof e)return R(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);"Object"===r&&e.constructor&&(r=e.constructor.name);if("Map"===r||"Set"===r)return Array.from(e);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return R(e,t)}(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var n=0,a=function(){};return{s:a,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,u=!0,o=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return u=e.done,e},e:function(e){o=!0,i=e},f:function(){try{u||null==r.return||r.return()}finally{if(o)throw i}}}}function R(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}(function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this._path=""}var t,r,n;return t=e,n=[{key:"getPtr",value:function(t){if(e._filePtrs.has(t))return e._filePtrs.get(t);throw new Error("File instance not found.")}},{key:"setPtr",value:function(t,r){e._filePtrs.set(t,r)}},{key:"removePtr",value:function(t){e._filePtrs.delete(t)}}],(r=[{key:"meta",get:function(){if(void 0!==this._meta)return Object.assign({version:0},this._meta)}},{key:"pageSize",get:function(){}}])&&M(t.prototype,r),n&&M(t,n),Object.defineProperty(t,"prototype",{writable:!1}),e}())._filePtrs=new Map;var A,F=function(){function e(t,r){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),a(this,"_numCommandsEncoded",void 0),a(this,"_commandEncoder",void 0),a(this,"_passEncoder",void 0),a(this,"_stageBuffersPendingMap",void 0),a(this,"_uniformBuffersPendingRelease",void 0),a(this,"device",void 0),a(this,"bufferReusePool",void 0),a(this,"shaders",void 0),a(this,"isTimerEnabled",void 0),a(this,"timestampBuffers",void 0),a(this,"shaderTimes",void 0),a(this,"adapterInfo",void 0),this._numCommandsEncoded=0,this._commandEncoder=null,this._passEncoder=null,this._stageBuffersPendingMap=[],this._uniformBuffersPendingRelease=[],this.device=t,this.bufferReusePool=new Map,this.shaders={},this.shaderTimes={},this.timestampBuffers={},this.isTimerEnabled=!1,this.adapterInfo=r}var r,n,i,u;return r=e,n=[{key:"getBufferKey",value:function(e,t){return"".concat(t,"_").concat(e)}},{key:"commandEncoder",get:function(){return this._commandEncoder||(this._commandEncoder=this.device.createCommandEncoder()),this._commandEncoder}},{key:"numCommandsEncoded",get:function(){return this._numCommandsEncoded},set:function(e){this._numCommandsEncoded=e,this._numCommandsEncoded>=16&&(this.endComputePass(),this.flushCommandEncoder())}},{key:"endComputePass",value:function(){this._passEncoder&&(this._passEncoder.end(),this._passEncoder=null)}},{key:"getBuffer",value:function(e,t){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3?arguments[3]:void 0,a=this.getBufferKey(e,t);if(this.bufferReusePool.has(a)){var i=this.bufferReusePool.get(a);if(i&&i.length>0)return i.pop()}return this.device.createBuffer({size:e*Uint8Array.BYTES_PER_ELEMENT,usage:t,mappedAtCreation:r,label:n})}},{key:"scheduleUniformBufferForRelease",value:function(e){this._uniformBuffersPendingRelease.push(e)}},{key:"releaseBuffer",value:function(e){(!(arguments.length>1&&void 0!==arguments[1])||arguments[1])&&(this.endComputePass(),this.commandEncoder.clearBuffer(e,0,e.size));var t=this.getBufferKey(e.size,e.usage);this.bufferReusePool.has(t)||this.bufferReusePool.set(t,[]),this.bufferReusePool.get(t).push(e)}},{key:"sync",value:(u=t(_.mark((function e(){var t,r,n,a,i,u,o,s,c,l,d=this;return _.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return this.flushCommandEncoder(),e.next=3,this.device.queue.onSubmittedWorkDone();case 3:t=L(this.bufferReusePool.keys());try{for(t.s();!(r=t.n()).done;)if(n=r.value,(a=this.bufferReusePool.get(n))&&a.length>0){i=L(a);try{for(i.s();!(u=i.n()).done;)null==(o=u.value)||o.destroy()}catch(e){i.e(e)}finally{i.f()}}}catch(e){t.e(e)}finally{t.f()}this.bufferReusePool.clear(),s=_.mark((function e(){var t,r,n,a,i,u;return _.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:t=G(l[c],2),r=t[0],n=t[1],d.shaderTimes[r]||(d.shaderTimes[r]=[]),a=L(n),e.prev=3,u=_.mark((function e(){var t;return _.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:(t=i.value).mapAsync(GPUMapMode.READ).then((function(){var e=new BigInt64Array(t.getMappedRange()),n=e[1]-e[0];t.unmap(),t.destroy(),d.shaderTimes[r].push(n)}));case 2:case"end":return e.stop()}}),e)})),a.s();case 6:if((i=a.n()).done){e.next=10;break}return e.delegateYield(u(),"t0",8);case 8:e.next=6;break;case 10:e.next=15;break;case 12:e.prev=12,e.t1=e.catch(3),a.e(e.t1);case 15:return e.prev=15,a.f(),e.finish(15);case 18:case"end":return e.stop()}}),e,null,[[3,12,15,18]])})),c=0,l=Object.entries(this.timestampBuffers);case 8:if(!(c<l.length)){e.next=13;break}return e.delegateYield(s(),"t0",10);case 10:c++,e.next=8;break;case 13:this.timestampBuffers={};case 14:case"end":return e.stop()}}),e,this)}))),function(){return u.apply(this,arguments)})},{key:"reportShaderTimes",value:function(){for(var e=0,t=Object.entries(this.shaderTimes);e<t.length;e++){var r,n=G(t[e],2),a=n[0],i=n[1],u=0n,o=L(i);try{for(o.s();!(r=o.n()).done;)u+=r.value}catch(e){o.e(e)}finally{o.f()}var s=1e-9*Number(u),c=(s/i.length).toFixed(7);console.log("".concat(a,", ").concat(s.toFixed(5),", ").concat(c))}this.shaderTimes={}}},{key:"flushCommandEncoder",value:function(){var e=this;this.device.queue.submit([this.commandEncoder.finish()]),this._commandEncoder=null,this._numCommandsEncoded=0,this._stageBuffersPendingMap.forEach((function(e){e.destroy()})),this._stageBuffersPendingMap=[],this._uniformBuffersPendingRelease.forEach((function(t){e.releaseBuffer(t,!1)})),this._uniformBuffersPendingRelease=[]}},{key:"writeBuffer",value:function(e,t,r,n){var a=this.getBuffer(e,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0);new Uint8Array(a.getMappedRange()).set(r),a.unmap(),this._stageBuffersPendingMap.push(a),this.endComputePass(),this.commandEncoder.copyBufferToBuffer(a,0,n,t,e),this.numCommandsEncoded++}},{key:"dispatchComputerShader",value:function(e,t,r,n,a,i){if(this.isTimerEnabled){var u=this.device.createQuerySet({type:"timestamp",count:2}),o={querySet:u,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1};this.endComputePass(),this._passEncoder=this.commandEncoder.beginComputePass({timestampWrites:o}),this._passEncoder.setBindGroup(0,e),this._passEncoder.setPipeline(t),this._passEncoder.dispatchWorkgroups(n,a,i),this.endComputePass();var s=2*BigInt64Array.BYTES_PER_ELEMENT,c=this.device.createBuffer({size:s,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC});this.commandEncoder.resolveQuerySet(u,0,2,c,0);var l=this.device.createBuffer({size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});this.commandEncoder.copyBufferToBuffer(c,0,l,0,s),this.timestampBuffers[r]||(this.timestampBuffers[r]=[]),this.timestampBuffers[r].push(l),this.numCommandsEncoded+=3}else this._passEncoder||(this._passEncoder=this.commandEncoder.beginComputePass()),this._passEncoder.setBindGroup(0,e),this._passEncoder.setPipeline(t),this._passEncoder.dispatchWorkgroups(n,a,i),this.numCommandsEncoded++}}],n&&T(r.prototype,n),i&&T(r,i),Object.defineProperty(r,"prototype",{writable:!1}),e}(),N=256,Y=new Map,W=new Map,I="\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main_empty() {}\n",q="main",V="pv_picollm_attention_precompute_encoding_shader",K="\nstruct argsStruct {\n  dimension: u32,\n  steps: u32,\n  theta: f32,\n  encoding_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> encoding: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(local_invocation_id) local_id: vec3<u32>,\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\n  @builtin(num_workgroups) num_workgroups: vec3<u32>\n) {\n  let ts = workgroup_id.x;\n  let ds = local_id.x;\n  \n  for (var t = ts; t < args.steps; t += num_workgroups.x) {\n    for (var d = ds; d < (args.dimension / 2u); d += workgroup_size_x) {\n      let f = 2u * d;\n      let x = f32(t) / pow(args.theta, f32(f) / f32(args.dimension));\n      let encoding_idx = args.encoding_offset + (t * args.dimension) + f;\n      encoding[encoding_idx] = cos(x);\n      encoding[encoding_idx + 1] = sin(x);\n    }\n  }            \n}\n\n".concat(I),D="pv_picollm_attention_encode_rope_interleaved_shader",Q="\nstruct argsStruct {  \n  n: u32,\n  num_heads: u32,\n  head_dimension: u32,\n  rope_dimension: u32,\n  position: u32,\n  encoding_offset: u32,\n  x_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> encoding: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> x: array<f32>;\n          \noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(local_invocation_id) local_id: vec3<u32>,\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\n  @builtin(num_workgroups) num_workgroups: vec3<u32>\n) {\n  let ts = workgroup_id.x;\n  let h = workgroup_id.y;\n  let ds = local_id.x;\n\n  for (var t = ts; t < args.n; t += num_workgroups.x) {\n    let x_start = args.x_offset + (t * args.num_heads + h) * args.head_dimension;\n    let encoding_start = args.encoding_offset + ((t + args.position) * args.rope_dimension);    \n    for (var d = ds; d < (args.head_dimension / 2u); d += workgroup_size_x) {\n      let i = 2u * d;\n      let x_idx = x_start + i;\n      let encoding_idx = encoding_start + i;\n      \n      let re = x[x_idx];\n      let im = x[x_idx + 1];\n      x[x_idx] = (re * encoding[encoding_idx]) - (im * encoding[encoding_idx + 1]);\n      x[x_idx + 1] = (re * encoding[encoding_idx + 1]) + (im * encoding[encoding_idx]);\n    }\n  }\n}\n\n".concat(I),X="pv_picollm_attention_encode_shader",H="\nstruct argsStruct {  \n  n: u32,\n  num_heads: u32,\n  head_dimension: u32,\n  rope_dimension: u32,\n  position: u32,\n  encoding_offset: u32,\n  x_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> encoding: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> x: array<f32>;\n          \noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(local_invocation_id) local_id: vec3<u32>,\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\n  @builtin(num_workgroups) num_workgroups: vec3<u32>\n) {\n  let ts = workgroup_id.x;\n  let h = workgroup_id.y;\n  let ds = local_id.x;\n\n  for (var t = ts; t < args.n; t += num_workgroups.x) {\n    let half_rope = (args.rope_dimension / 2);\n    let xr_start = args.x_offset + ((t * args.num_heads + h) * args.head_dimension);\n    let xi_start = xr_start + half_rope;\n    let encoding_start = args.encoding_offset + ((t + args.position) * args.rope_dimension);  \n    for (var d = ds; d < half_rope; d += workgroup_size_x) {\n      let xr_idx = xr_start + d;\n      let xi_idx = xi_start + d;\n      let encoding_idx = encoding_start + (2 * d);\n\n      let re = x[xr_idx];\n      let im = x[xi_idx];\n      x[xr_idx] = (re * encoding[encoding_idx]) - (im * encoding[encoding_idx + 1]);\n      x[xi_idx] = (re * encoding[encoding_idx + 1]) + (im * encoding[encoding_idx]);\n    }\n  }\n}\n\n".concat(I),Z="pv_picollm_attention_dot_product_shader",J="\nstruct argsStruct {  \n  n: u32,\n  tq: u32,\n  head_dimension: u32,\n  num_heads: u32,\n  num_kv_heads: u32,\n  window_length: u32,\n  start: u32,\n  norm: f32,\n  length1: u32,\n  num_keys: u32,\n  query_offset: u32,\n  keys_offset: u32,\n  key_intercepts_offset: u32,\n  key_slopes_offset: u32,\n  scores_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> query: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> keys: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> key_intercepts: array<f32>;\n\n@group(0) @binding(4)\nvar<storage, read> key_slopes: array<f32>;\n\n@group(0) @binding(5)\nvar<storage, read_write> scores: array<f32>;\n       \noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.num_heads) {\n    return;\n  }\n\n  let head = global_id.x / (args.num_heads / args.num_kv_heads);\n  \n  let head_offset = head * args.window_length;\n  let start_index = head_offset + args.start;\n    \n  let keys_local_a = args.keys_offset + (start_index * args.head_dimension);\n  let key_intercepts_local_a = args.key_intercepts_offset + start_index;  \n  let key_slopes_local_a = args.key_slopes_offset + start_index;\n  \n  let keys_local_b = args.keys_offset + (head_offset * args.head_dimension);\n  let key_intercepts_local_b = args.key_intercepts_offset + head_offset;  \n  let key_slopes_local_b = args.key_slopes_offset + head_offset;\n  \n  let scores_local = args.scores_offset + (global_id.x * args.num_keys);\n  let query_local = args.query_offset + (((global_id.x * args.n) + args.tq) * args.head_dimension);\n    \n  for (var i = 0u; i < args.head_dimension; i++) {      \n    for (var k = 0u; k < args.num_keys; k++) {\n      if (k < args.length1) { \n        let key_idx = keys_local_a + (k * args.head_dimension) + i;\n        let key_val = f32(extractBits(keys[key_idx / 4], (i * 8u) % 32u, 8u));\n        let tmp = query[query_local + i] * (key_intercepts[key_intercepts_local_a + k] + (key_slopes[key_slopes_local_a + k] * key_val));\n        scores[scores_local + k] += tmp;\n      }\n      else {\n        let j = k - args.length1;\n        let key_idx = keys_local_b + (j * args.head_dimension) + i;\n        let key_val = f32(extractBits(keys[key_idx / 4], (i * 8u) % 32u, 8u));\n        let tmp = query[query_local + i] * (key_intercepts[key_intercepts_local_b + j] + (key_slopes[key_slopes_local_b + j] * key_val));\n        scores[scores_local + k] += tmp;\n      }\n    }    \n  }\n  \n  for (var k = 0u; k < args.num_keys; k++) {\n    scores[scores_local + k] *= args.norm;\n  }\n}\n\n".concat(I),$="pv_picollm_attention_softmax_shader",ee="\nstruct argsStruct {  \n  num_heads: u32,\n  num_keys: u32,\n  scores_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> scores: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.num_heads) {\n    return;\n  }\n\n  let scores_start = args.scores_offset + (global_id.x * args.num_keys);\n  \n  var max_index: u32 = 0;\n  for (var i = 1u; i < args.num_keys; i++) {\n    if (scores[scores_start + i] > scores[scores_start + max_index]) {\n      max_index = i;\n    }\n  }\n  let max: f32 = scores[scores_start + max_index];\n\n  var sum: f32 = 0.0;\n  for (var i = 0u; i < args.num_keys; i++) {\n    scores[scores_start + i] = exp(scores[scores_start + i] - max);\n    sum += scores[scores_start + i];\n  }\n\n  for (var i = 0u; i < args.num_keys; i++) {\n    scores[scores_start + i] /= sum;\n  }\n}\n\n".concat(I),te="pv_picollm_attention_fir_shader",re="\nstruct argsStruct {  \n  length1: u32,\n  length2: u32,\n  tq: u32,\n  head_dimension: u32,\n  num_heads: u32,\n  num_kv_heads: u32,\n  window_length: u32,\n  start: u32,\n  values_offset: u32,\n  value_intercepts_offset: u32,\n  value_slopes_offset: u32,\n  scores_offset: u32,\n  output_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> values: array<u32>;\n\n@group(0) @binding(2)\nvar<storage, read> value_intercepts: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read> value_slopes: array<f32>;\n\n@group(0) @binding(4)\nvar<storage, read> scores: array<f32>;\n\n@group(0) @binding(5)\nvar<storage, read_write> output: array<f32>;\n          \noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.num_heads) {\n    return;\n  }\n\n  let head = global_id.x / (args.num_heads / args.num_kv_heads);\n\n  let head_offset = head * args.window_length;\n  let start_index = head_offset + args.start;\n\n  let values_local_a = args.values_offset + (start_index * args.head_dimension);\n  let value_intercepts_local_a = args.value_intercepts_offset + start_index;\n  let value_slopes_local_a = args.value_slopes_offset + start_index;\n  let values_local_b = args.values_offset + (head_offset * args.head_dimension);\n  let value_intercepts_local_b = args.value_intercepts_offset + head_offset;\n  let value_slopes_local_b = args.value_slopes_offset + head_offset;\n  let scores_local = args.scores_offset + (global_id.x * (args.length1 + args.length2));\n  let output_local = args.output_offset + (((args.tq * args.num_heads) + global_id.x) * args.head_dimension);\n\n  for (var i = 0u; i < args.head_dimension; i++) {\n    var tmp: f32 = 0.0;\n    for (var k = 0u; k < args.length1; k++) {\n      let value_idx = values_local_a + (k * args.head_dimension) + i;\n      let value_val = f32(extractBits(values[value_idx / 4], (i * 8u) % 32u, 8u));\n      tmp += scores[scores_local + k] * (value_intercepts[value_intercepts_local_a + k] + (value_slopes[value_slopes_local_a + k] * value_val));             \n    }\n    for (var k = 0u; k < args.length2; k++) {\n      let value_idx = values_local_b + (k * args.head_dimension) + i;\n      let value_val = f32(extractBits(values[value_idx / 4], (i * 8u) % 32u, 8u));\n      tmp += scores[scores_local + args.length1 + k] * (value_intercepts[value_intercepts_local_b + k] + (value_slopes[value_slopes_local_b + k] * value_val));      \n    }\n    output[output_local + i] = tmp;\n  }\n}\n\n".concat(I),ne="pv_picollm_attention_update_kv_shader",ae="\nstruct argsStruct {\n  n: u32,\n  num_kv_heads: u32,\n  window_length: u32,\n  position: u32,\n  head_dimension: u32,\n  tf_offset: u32,\n  kv_offset: u32,\n  kv_intercepts_offset: u32,\n  kv_slopes_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> tf: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> kv: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> kv_intercepts: array<f32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> kv_slopes: array<f32>;\n          \noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {  \n  if (global_id.x >= args.num_kv_heads) {\n    return;\n  }\n  \n  for (var i = 0u; i < args.n; i++) {\n    let index = (global_id.x * args.window_length) + ((args.position + i) % args.window_length);\n    let tf_start = args.tf_offset + (((i * args.num_kv_heads) + global_id.x) * args.head_dimension);\n    let kv_start = args.kv_offset + ((index * args.head_dimension) / 4);\n    let kv_intercepts_start = args.kv_intercepts_offset + index;\n    let kv_slopes_start = args.kv_slopes_offset + index;\n    \n    var xmax = tf[tf_start];    \n    var xmin = tf[tf_start];    \n    \n    for (var j = 1u; j < args.head_dimension; j++) {\n      xmax = max(xmax, tf[tf_start + j]);\n      xmin = min(xmin, tf[tf_start + j]);\n    }\n\n    kv_intercepts[kv_intercepts_start] = xmin;\n    kv_slopes[kv_slopes_start] = f32(xmax - xmin) / 255.0;\n\n    for (var j = 0u; j < args.head_dimension; j++) {\n      let kv_idx = kv_start + (j / 4);\n      let kv_val = u32(round((tf[tf_start + j] - xmin) / kv_slopes[kv_slopes_start]));      \n      kv[kv_idx] = insertBits(kv[kv_idx], extractBits(kv_val, 0u, 8u), (j * 8u) % 32u, 8u);      \n    }\n  }\n}\n\n".concat(I),ie="pv_picollm_attention_transpose_query_shader",ue="\nstruct argsStruct {\n  n: u32,\n  num_heads: u32,\n  head_dimension: u32,\n  tf_offset: u32,\n  hf_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> tf: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> hf: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(workgroup_id) workgroup_id : vec3<u32>,\n  @builtin(local_invocation_id) local_id : vec3<u32>\n) {\n\n  if (workgroup_id.x >= args.num_heads || workgroup_id.y >= args.n || local_id.x >= args.head_dimension) {\n    return;\n  }\n  \n  let tf_idx = args.tf_offset + (workgroup_id.y * args.num_heads * args.head_dimension) + (workgroup_id.x * args.head_dimension) + local_id.x; \n  let hf_idx = args.hf_offset + (workgroup_id.x * args.n * args.head_dimension) + (workgroup_id.y * args.head_dimension) + local_id.x;  \n  hf[hf_idx] = tf[tf_idx];\n}\n\n".concat(I),oe=a(a(a(a(a(a(a(a({},V,(function(e){var t=e.createBindGroupLayout({label:"attention precompute encoding bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"attention precompute encoding pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"attention precompute encoding shader module",code:K});return{computePipeline:e.createComputePipeline({label:"attention precompute encoding pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),D,(function(e){var t=e.createBindGroupLayout({label:"attention encode rope interleave bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"attention encode rope interleave pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"attention encode rope interleave shader module",code:Q});return{computePipeline:e.createComputePipeline({label:"attention encode rope interleave pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),X,(function(e){var t=e.createBindGroupLayout({label:"attention encode bind layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"attention encode pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"attention encode shader",code:H});return{computePipeline:e.createComputePipeline({label:"attention encode pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),Z,(function(e){var t=e.createBindGroupLayout({label:"attention dot product bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"attention dot product pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"attention dot product shader module",code:J});return{computePipeline:e.createComputePipeline({label:"attention dot product pipeline",layout:r,compute:{module:n,entryPoint:q}})}})),$,(function(e){var t=e.createBindGroupLayout({label:"attention softmax bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"attention softmax pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"attention softmax shader module",code:ee});return{computePipeline:e.createComputePipeline({label:"attention softmax pipeline",layout:r,compute:{module:n,entryPoint:q}})}})),te,(function(e){var t=e.createBindGroupLayout({label:"attention fir bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"attention fir pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"attention fir shader module",code:re});return{computePipeline:e.createComputePipeline({label:"attention fir pipeline",layout:r,compute:{module:n,entryPoint:q}})}})),ne,(function(e){var t=e.createBindGroupLayout({label:"attention update kv bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"attention update kv pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"attention update kv shader module",code:ae});return{computePipeline:e.createComputePipeline({label:"attention update kv pipeline",layout:r,compute:{module:n,entryPoint:q}})}})),ie,(function(e){var t=e.createBindGroupLayout({label:"attention transpose query bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"attention transpose query pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"attention transpose query shader module",code:ue});return{computePipeline:e.createComputePipeline({label:"attention transpose query pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),se="pv_picollm_feed_forward_silu_shader",ce="\nstruct argsStruct {\n  n: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> x: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n  x[global_id.x] = x[global_id.x] / (1.0 + exp(-x[global_id.x]));\n}\n\n".concat(I),le="pv_picollm_feed_forward_gelu_shader",_e="\nstruct argsStruct {\n  n: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> x: array<f32>;\n\nconst a1: f32 = 0.254829592;\nconst a2: f32 = -0.284496736;\nconst a3: f32 = 1.421413741;\nconst a4: f32 = -1.453152027;\nconst a5: f32 = 1.061405429;\nconst p: f32 = 0.3275911;\n\n// A&S formula 7.1.26\nfn erf(x: f32) -> f32 {    \n    var sign: f32 = 1.0;\n    if (x < 0) {\n        sign = -1.0;\n    }\n    var x_abs: f32 = abs(x);\n    \n    let t: f32 = 1.0 / fma(p, x_abs, 1.0);\n    let y: f32 = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-x_abs * x_abs);\n\n    return sign * y;\n}\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n  x[global_id.x] = 0.5 * x[global_id.x] * (1.0 + erf(x[global_id.x] * 0.7071067811865475));\n}\n\n".concat(I),de="pv_picollm_feed_forward_almost_gelu_shader",fe="\nstruct argsStruct {\n  n: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> x: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n  x[global_id.x] = 0.5 * x[global_id.x] * (1 + tanh(0.7978845608028654 * (x[global_id.x] + (0.044715f * x[global_id.x] * x[global_id.x] * x[global_id.x]))));\n}\n\n".concat(I),be="pv_picollm_feed_forward_multiply_buffers_shader",pe="\nstruct argsStruct {\n  n: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n  y[global_id.x] *= x[global_id.x];\n}\n\n".concat(I),ge=a(a(a(a({},se,(function(e){var t=e.createBindGroupLayout({label:"ff silu bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"ff silu pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"ff silu shader module",code:ce});return{computePipeline:e.createComputePipeline({label:"ff silu pipline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),le,(function(e){var t=e.createBindGroupLayout({label:"ff gelu bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"ff gelu pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"ff gelu shader module",code:_e});return{computePipeline:e.createComputePipeline({label:"ff gelu pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),de,(function(e){var t=e.createBindGroupLayout({label:"ff almost gelu bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"ff almost gelu pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"ff almost gelu shader module",code:fe});return{computePipeline:e.createComputePipeline({label:"ff almost gelu pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),be,(function(e){var t=e.createBindGroupLayout({label:"ff multiply buffers bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"ff multiply buffers pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"ff multiply buffers shader module",code:pe});return{computePipeline:e.createComputePipeline({label:"ff multiply buffers pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),ve="pv_picollm_gate_forward_shader",xe="\n\nstruct pv_picollm_gate_ix_t {\n  i: u32,\n  x: f32,\n}\n\n@group(0) @binding(0)\nvar<storage, read> y: array<f32>;\n\n@group(0) @binding(1)\nvar<storage, read_write> indices: array<u32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> weights: array<f32>;\n\noverride n: u32 = 0;\noverride k: u32 = 0;\noverride num_experts: u32 = 0;\n\noverride y_offset: u32 = 0;\noverride indices_offset: u32 = 0;\noverride weights_offset: u32 = 0;\n\nvar<workgroup> ixs: array<pv_picollm_gate_ix_t, num_experts>;\n  \noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(global_invocation_id) global_id : vec3<u32>\n) {\n  if (global_id.x >= n) {\n    return;\n  }\n  \n  var y_start: u32 = y_offset + global_id.x * num_experts;\n  for (var j = 0u; j < num_experts; j++) {\n      ixs[j].i = j;\n      ixs[j].x = y[y_start + j];\n  }\n\n  for (var i = 0u; i < num_experts - 1; i++) {\n    for (var j = 0u; j < num_experts - i - 1; j++) {\n      if (ixs[j].x < ixs[j + 1].x) {\n        let tmp = ixs[j];\n        ixs[j] = ixs[j + 1];\n        ixs[j + 1] = tmp;\n      }\n    }\n  }\n\n  for (var j = 0u; j < k; j++) {\n      indices[indices_offset + (global_id.x * k) + j] = ixs[j].i;\n      weights[weights_offset + (global_id.x * k) + j] = ixs[j].x;\n  }\n\n  var max_weight: f32 = weights[weights_offset + (global_id.x * k)];\n  for (var j = 1u; j < k; j++) {\n      max_weight = max(max_weight, weights[weights_offset + (global_id.x * k) + j]);\n  }\n\n  var sum_weight: f32 = 0.0;\n  for (var j = 0u; j < k; j++) {\n      weights[weights_offset + (global_id.x * k) + j] = exp(weights[weights_offset + (global_id.x * k) + j] - max_weight);\n      sum_weight += weights[weights_offset + (global_id.x * k) + j];\n  }\n\n  for (var j = 0u; j < k; j++) {\n      weights[weights_offset + (global_id.x * k) + j] /= sum_weight;\n  }\n}\n\n".concat(I),ke=a({},ve,(function(e){var t=e.createBindGroupLayout({label:"gate forward bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"gate forward pipeline",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"gate forward shader module",code:xe});return{computePipeline:e.createComputePipeline({layout:r,compute:{module:n,entryPoint:q,constants:{num_experts:1}}}),pipelineLayout:r,shaderModule:n}})),me="pv_picollm_moe_transformer_add_to_buffer_shader",he="\nstruct argsStruct {\n  n: u32,  \n  x_offset: u32,\n  buffer_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> buffer: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n\n  buffer[args.buffer_offset + global_id.x] += x[args.x_offset + global_id.x];  \n}\n\n".concat(I),ye="pv_picollm_moe_transformer_multiply_weight_and_add_to_buffer_shader",Be="\nstruct argsStruct {\n  n: u32,  \n  weights_index: u32,\n  y_index: u32,\n  weights_offset: u32,\n  x_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> weights: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n    \n  y[args.y_offset + args.y_index + global_id.x] += weights[args.weights_index] + x[args.x_offset + global_id.x];   \n}\n\n".concat(I),we="pv_picollm_moe_transformer_add_buffers_shader",Pe="\nstruct argsStruct {\n  n: u32,  \n  buffer1_offset: u32,\n  buffer2_offset: u32,\n  y_offset: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> buffer1: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> buffer2: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n    \n  y[args.y_offset + global_id.x] = buffer1[args.buffer1_offset + global_id.x] + buffer2[args.buffer2_offset + global_id.x];   \n}\n\n".concat(I),Se=a(a(a({},me,(function(e){var t=e.createBindGroupLayout({label:"moe transformer add to buffer bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"moe transformer add to buffer pipeline",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"moe transformer add to buffer shader module",code:he});return{computePipeline:e.createComputePipeline({label:"moe transformer add to buffer pipeline",layout:r,compute:{module:n,entryPoint:q}})}})),ye,(function(e){var t=e.createBindGroupLayout({label:"moe transformer multiply weight and add to buffer bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"moe transformer multiply weight and add to buffer pipeline",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"moe transformer multiply weight and add to buffer shader module",code:Be});return{computePipeline:e.createComputePipeline({label:"moe transformer multiply weight and add to buffer pipeline",layout:r,compute:{module:n,entryPoint:q}})}})),we,(function(e){var t=e.createBindGroupLayout({label:"moe transformer add buffers bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"moe transformer add buffers pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"moe transformer add buffers shader module",code:Pe});return{computePipeline:e.createComputePipeline({label:"moe transformer add buffers pipeline",layout:r,compute:{module:n,entryPoint:q}})}})),Ee="pv_picollm_norm_forward_multi_buffer_shader",Ue="pv_picollm_norm_forward_single_buffer_shader",ze=function(e){return"\nstruct argsStruct {\n  n: u32,\n  dimension: u32,\n  remainder: u32,\n  remainder_start: u32, \n  eps: f32,  \n  x_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> weight: array<f32>;\n\n".concat(e?"\n@group(0) @binding(2)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(3) \nvar<storage, read_write> y: array<f32>;\n":"    \n@group(0) @binding(2)\nvar<storage, read_write> x: array<f32>;\n","\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\nvar<workgroup> sdata: array<vec4<f32>, workgroup_size_x>;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(local_invocation_id) local_id: vec3<u32>,\n  @builtin(workgroup_id) workgroup_id: vec3<u32>\n) {\n  let tid = local_id.x;\n  let m = workgroup_id.x;\n  let block_size = workgroup_size_x;\n  \n  var power_vec: vec4<f32>;\n  let x_start: u32 = args.x_offset + (m * args.dimension);\n  let skip = tid * 4;\n  let shift = (block_size * 4);\n  for (var j = 0u; j + skip < args.remainder_start; j += shift) {\n    let local_index = x_start + j + skip; \n\n    let x_vec = vec4(\n      x[local_index],\n      x[local_index + 1],\n      x[local_index + 2],\n      x[local_index + 3]);\n    \n    power_vec += x_vec * x_vec; \n  }  \n  \n  if (tid == 0 && args.remainder > 0) {\n    var remainder_vec = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n    let x_idx = x_start + args.remainder_start;\n    for (var j = 0u; j < args.remainder; j++) {       \n      remainder_vec[j] = x[x_idx + j];\n    }    \n    power_vec += remainder_vec * remainder_vec;\n  }\n  \n  sdata[tid] = power_vec;\n  workgroupBarrier();\n\n  ").concat("\n  for (var s: u32 = workgroup_size_x / 2; s > 0; s >>= 1) {\n    if tid < s {\n        sdata[tid] += sdata[tid + s];\n    }\n    workgroupBarrier();\n  }\n","\n  \n  let power = sdata[0].x + sdata[0].y + sdata[0].z + sdata[0].w;\n  let norm: vec4<f32> = vec4(1.0 / sqrt((power / f32(args.dimension)) + args.eps));\n  \n  let y_start: u32 = args.y_offset + (m * args.dimension);\n  for (var j = 0u; j + skip < args.remainder_start; j += shift) {\n    let local_index = j + skip;\n    let x_idx = x_start + local_index;\n    let x_vec = vec4(\n      x[x_idx],\n      x[x_idx + 1],\n      x[x_idx + 2],\n      x[x_idx + 3]);\n          \n    let weight_vec = vec4(\n      weight[local_index],\n      weight[local_index + 1],\n      weight[local_index + 2],\n      weight[local_index + 3]);\n    let y_vec = x_vec * norm * weight_vec;\n    \n    let y_idx = y_start + local_index;\n").concat(e?" \n    y[y_idx] = y_vec.x;\n    y[y_idx + 1] = y_vec.y;\n    y[y_idx + 2] = y_vec.z;\n    y[y_idx + 3] = y_vec.w;\n":"    \n    x[y_idx] = y_vec.x;\n    x[y_idx + 1] = y_vec.y;\n    x[y_idx + 2] = y_vec.z;\n    x[y_idx + 3] = y_vec.w;\n","   \n  }\n  \n  if (tid == 0 && args.remainder > 0) {\n    let x_idx = x_start + args.remainder_start;\n    let weight_idx = args.remainder_start;    \n    let y_idx = y_start + args.remainder_start;\n    for (var j = 0u; j < args.remainder; j++) {\n").concat(e?"    \n      y[y_idx + j] = x[x_idx + j] * norm[j] * weight[weight_idx + j];\n":"    \n      x[y_idx + j] = x[x_idx + j] * norm[j] * weight[weight_idx + j];\n"," \n    }    \n  }\n}\n\n").concat(I)},je=function(e,t){var r=[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}];t?(r.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),r.push({binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}})):r.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}});var n=e.createBindGroupLayout({label:"norm forward ".concat(t?"multi":"single"," buffer bind group layout"),entries:r}),a=e.createPipelineLayout({label:"norm forward ".concat(t?"multi":"single"," buffer pipeline layout"),bindGroupLayouts:[n]}),i=e.createShaderModule({label:"norm forward ".concat(t?"multi":"single"," buffer shader module"),code:ze(t)});return{computePipeline:e.createComputePipeline({label:"norm forward ".concat(t?"multi":"single"," buffer pipeline"),layout:a,compute:{module:i,entryPoint:q,constants:{workgroup_size_x:N}}})}},Me=a(a({},Ue,(function(e){return je(e,!1)})),Ee,(function(e){return je(e,!0)})),Ce="pv_picollm_norm_layer_forward_multi_buffer_shader",Oe="\nstruct argsStruct {\n  n: u32,\n  dimension: u32,\n  eps: f32,\n  weight_offset: u32,\n  bias_offset: u32,\n  x_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> weight: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> bias: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n  \n  let x_start: u32 = args.x_offset + (global_id.x * args.dimension);\n\n  var mean: f32 = 0.0;\n  for (var j = 0u; j < args.dimension; j++) {\n      mean += x[x_start + j];\n  }\n  mean /= f32(args.dimension);\n\n  var mean2: f32 = 0.0;\n  for (var j = 0u; j < args.dimension; j++) {\n      mean2 += (x[x_start + j] - mean) * (x[x_start + j] - mean);\n  }\n  mean2 /= f32(args.dimension);\n\n  var norm: f32 = 1.0 / sqrt(mean2 + args.eps);\n\n  var y_start = args.y_offset + (global_id.x * args.dimension);\n  for (var j = 0u; j < args.dimension; j++) {\n    y[y_start + j] = ((x[x_start + j] - mean) * norm * weight[args.weight_offset + j]) + bias[args.bias_offset + j];\n  }\n}\n\n".concat(I),Ge="pv_picollm_norm_layer_forward_single_buffer_shader",Te="\nstruct argsStruct {\n  n: u32,\n  dimension: u32,\n  eps: f32,\n  weight_offset: u32,\n  bias_offset: u32,\n  x_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> weight: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> bias: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n  \n  let x_start: u32 = args.x_offset + (global_id.x * args.dimension);\n\n  var mean: f32 = 0.0;\n  for (var j = 0u; j < args.dimension; j++) {\n      mean += y[x_start + j];\n  }\n  mean /= f32(args.dimension);\n\n  var mean2: f32 = 0.0;\n  for (var j = 0u; j < args.dimension; j++) {\n      mean2 += (y[x_start + j] - mean) * (y[x_start + j] - mean);\n  }\n  mean2 /= f32(args.dimension);\n\n  var norm: f32 = 1.0 / sqrt(mean2 + args.eps);\n\n  var y_start = args.y_offset + (global_id.x * args.dimension);\n  for (var j = 0u; j < args.dimension; j++) {\n    y[y_start + j] = ((y[x_start + j] - mean) * norm * weight[args.weight_offset + j]) + bias[args.bias_offset + j];\n  }\n}\n\n".concat(I),Le=a(a({},Ge,(function(e){var t=e.createBindGroupLayout({label:"norm layer forward single buffer bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"norm layer forward single buffer pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"norm layer forward single buffer shader module",code:Te});return{computePipeline:e.createComputePipeline({label:"norm layer forward single buffer pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),Ce,(function(e){var t=e.createBindGroupLayout({label:"norm layer forward multi buffer bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"norm layer forward multi buffer pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"norm layer forward multi buffer shader module",code:Oe});return{computePipeline:e.createComputePipeline({label:"norm layer forward multi buffer pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),Re="pv_picollm_transformer_add_to_buffer_shader",Ae="\nstruct argsStruct {\n  n: u32,\n  x_offset: u32,\n  buffer_offset: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> buffer: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n    \n  buffer[args.buffer_offset + global_id.x] += x[args.x_offset + global_id.x];  \n}\n\n".concat(I),Fe="pv_picollm_transformer_add_buffers_shader",Ne="\n\nstruct argsStruct {\n  n: u32,\n  buffer1_offset: u32,\n  buffer2_offset: u32,\n  y_offset: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> buffer1: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> buffer2: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n    \n  y[args.y_offset + global_id.x] = buffer1[args.buffer1_offset + global_id.x] + buffer2[args.buffer2_offset + global_id.x];   \n}\n\n".concat(I),Ye=a(a({},Re,(function(e){var t=e.createBindGroupLayout({label:"transformer add to buffer bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"transformer add to buffer pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"transformer add to buffer shader module",code:Ae});return{computePipeline:e.createComputePipeline({label:"transformer add to buffer compute",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),Fe,(function(e){var t=e.createBindGroupLayout({label:"transformer add buffers bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"transformer add buffers pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"transformer add buffers shader module",code:Ne});return{computePipeline:e.createComputePipeline({label:"transformer add buffers pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),We="pv_picollm_weight_float_forward_shader",Ie="\n\nstruct argsStruct {\n  nr: u32,\n  nc: u32,\n  w_offset: u32,\n  x_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> w: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(workgroup_id) workgroup_id : vec3<u32>,\n  @builtin(local_invocation_id) local_id : vec3<u32>\n) {\n  if (local_id.x >= args.nr) {\n    return;\n  }\n  let x_start: u32 = args.x_offset + (workgroup_id.x * args.nc);\n  let y_idx: u32 = local_id.x + args.y_offset + (workgroup_id.x * args.nr);\n  \n  let w_start: u32 = args.w_offset + (local_id.x * args.nc);\n  for (var j = 0u; j < args.nc; j++) {\n    y[y_idx] += w[w_start + j] * x[x_start + j]; \n  }\n}\n\n".concat(I),qe=a({},We,(function(e){var t=e.createBindGroupLayout({label:"weight float forward bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"weight float forward pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"weight float forward shader module",code:Ie});return{computePipeline:e.createComputePipeline({label:"weight float forward pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),Ve=16,Ke="\n\nconst exponents: array<f32, 32> = array(\n  2.9103830456733704e-11, \n  5.820766091346741e-11, \n  1.1641532182693481e-10, \n  2.3283064365386963e-10,\n  4.656612873077393e-10, \n  9.313225746154785e-10, \n  1.862645149230957e-09, \n  3.725290298461914e-09,\n  7.450580596923828e-09, \n  1.4901161193847656e-08, \n  2.9802322387695312e-08, \n  5.960464477539063e-08,\n  1.1920928955078125e-07, \n  2.384185791015625e-07, \n  4.76837158203125e-07, \n  9.5367431640625e-07,\n  1.9073486328125e-06, \n  3.814697265625e-06, \n  7.62939453125e-06, \n  1.52587890625e-05, \n  3.0517578125e-05,\n  6.103515625e-05, \n  0.0001220703125, \n  0.000244140625, \n  0.00048828125, \n  0.0009765625, \n  0.001953125, \n  0.00390625,\n  0.0078125, \n  0.015625, \n  0.03125, \n  0.0625);\n\nfn from_fp510(x: u32) -> f32 {\n    let exponent = f32(exponents[extractBits(x, 10u, 5u)]);        \n    let fractional = f32(extractBits(x, 0u, 10u));        \n    let abs = exponent * fractional;\n    return abs * (1.0 - (2.0 * f32(extractBits(x, 15u, 1u))));\n}\n",De={3:"\n\nstruct argsStruct {\n  nbr: u32,\n  nbc: u32,\n  blocks_offset: u32\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> blocks: array<u32>;\n\n".concat("\nvar<private> unpacked: array<u32, 128>;\n\nfn unpack_block_128_bit_depth_3(packed_offset: u32) {\n  let val_0 = blocks[packed_offset]; \n  unpacked[0] = extractBits(val_0, 0u, 3u);\n  unpacked[1] = extractBits(val_0, 3u, 3u);\n  unpacked[2] = extractBits(val_0, 6u, 3u);\n  unpacked[3] = extractBits(val_0, 9u, 3u);\n  unpacked[4] = extractBits(val_0, 12u, 3u);\n  unpacked[5] = extractBits(val_0, 15u, 3u);\n  unpacked[6] = extractBits(val_0, 18u, 3u);\n  unpacked[7] = extractBits(val_0, 21u, 3u);\n  unpacked[8] = extractBits(val_0, 24u, 3u);\n  unpacked[9] = extractBits(val_0, 27u, 3u);\n  unpacked[10] = extractBits(val_0, 30u, 2u);\n  \n  let val_1 = blocks[packed_offset + 1];\n  unpacked[10] = insertBits(unpacked[10], extractBits(val_1, 0u, 1u), 2u, 1u);\n  unpacked[11] = extractBits(val_1, 1u, 3u);\n  unpacked[12] = extractBits(val_1, 4u, 3u);\n  unpacked[13] = extractBits(val_1, 7u, 3u);\n  unpacked[14] = extractBits(val_1, 10u, 3u);\n  unpacked[15] = extractBits(val_1, 13u, 3u);\n  unpacked[16] = extractBits(val_1, 16u, 3u);\n  unpacked[17] = extractBits(val_1, 19u, 3u);\n  unpacked[18] = extractBits(val_1, 22u, 3u);\n  unpacked[19] = extractBits(val_1, 25u, 3u);\n  unpacked[20] = extractBits(val_1, 28u, 3u);\n  unpacked[21] = extractBits(val_1, 31u, 1u);\n  \n  let val_2 = blocks[packed_offset + 2];\n  unpacked[21] = insertBits(unpacked[21], extractBits(val_2, 0u, 2u), 1u, 2u); \n  unpacked[22] = extractBits(val_2, 2u, 3u);\n  unpacked[23] = extractBits(val_2, 5u, 3u);\n  unpacked[24] = extractBits(val_2, 8u, 3u);\n  unpacked[25] = extractBits(val_2, 11u, 3u);\n  unpacked[26] = extractBits(val_2, 14u, 3u);\n  unpacked[27] = extractBits(val_2, 17u, 3u);\n  unpacked[28] = extractBits(val_2, 20u, 3u);\n  unpacked[29] = extractBits(val_2, 23u, 3u);\n  unpacked[30] = extractBits(val_2, 26u, 3u);\n  unpacked[31] = extractBits(val_2, 29u, 3u);\n  \n  let val_3 = blocks[packed_offset + 3]; \n  unpacked[32] = extractBits(val_3, 0u, 3u);\n  unpacked[33] = extractBits(val_3, 3u, 3u);\n  unpacked[34] = extractBits(val_3, 6u, 3u);\n  unpacked[35] = extractBits(val_3, 9u, 3u);\n  unpacked[36] = extractBits(val_3, 12u, 3u);\n  unpacked[37] = extractBits(val_3, 15u, 3u);\n  unpacked[38] = extractBits(val_3, 18u, 3u);\n  unpacked[39] = extractBits(val_3, 21u, 3u);\n  unpacked[40] = extractBits(val_3, 24u, 3u);\n  unpacked[41] = extractBits(val_3, 27u, 3u);\n  unpacked[42] = extractBits(val_3, 30u, 2u);\n  \n  let val_4 = blocks[packed_offset + 4];\n  unpacked[42] = insertBits(unpacked[42], extractBits(val_4, 0u, 1u), 2u, 1u);\n  unpacked[43] = extractBits(val_4, 1u, 3u);\n  unpacked[44] = extractBits(val_4, 4u, 3u);\n  unpacked[45] = extractBits(val_4, 7u, 3u);\n  unpacked[46] = extractBits(val_4, 10u, 3u);\n  unpacked[47] = extractBits(val_4, 13u, 3u);\n  unpacked[48] = extractBits(val_4, 16u, 3u);\n  unpacked[49] = extractBits(val_4, 19u, 3u);\n  unpacked[50] = extractBits(val_4, 22u, 3u);\n  unpacked[51] = extractBits(val_4, 25u, 3u);\n  unpacked[52] = extractBits(val_4, 28u, 3u);\n  unpacked[53] = extractBits(val_4, 31u, 1u);\n  \n  let val_5 = blocks[packed_offset + 5];\n  unpacked[53] = insertBits(unpacked[53], extractBits(val_5, 0u, 2u), 1u, 2u); \n  unpacked[54] = extractBits(val_5, 2u, 3u);\n  unpacked[55] = extractBits(val_5, 5u, 3u);\n  unpacked[56] = extractBits(val_5, 8u, 3u);\n  unpacked[57] = extractBits(val_5, 11u, 3u);\n  unpacked[58] = extractBits(val_5, 14u, 3u);\n  unpacked[59] = extractBits(val_5, 17u, 3u);\n  unpacked[60] = extractBits(val_5, 20u, 3u);\n  unpacked[61] = extractBits(val_5, 23u, 3u);\n  unpacked[62] = extractBits(val_5, 26u, 3u);\n  unpacked[63] = extractBits(val_5, 29u, 3u);\n  \n  let val_6 = blocks[packed_offset + 6];\n  unpacked[64] = extractBits(val_6, 0u, 3u);\n  unpacked[65] = extractBits(val_6, 3u, 3u);\n  unpacked[66] = extractBits(val_6, 6u, 3u);\n  unpacked[67] = extractBits(val_6, 9u, 3u);\n  unpacked[68] = extractBits(val_6, 12u, 3u);\n  unpacked[69] = extractBits(val_6, 15u, 3u);\n  unpacked[70] = extractBits(val_6, 18u, 3u);\n  unpacked[71] = extractBits(val_6, 21u, 3u);\n  unpacked[72] = extractBits(val_6, 24u, 3u);\n  unpacked[73] = extractBits(val_6, 27u, 3u);\n  unpacked[74] = extractBits(val_6, 30u, 2u);\n  \n  let val_7 = blocks[packed_offset + 7];\n  unpacked[74] = insertBits(unpacked[74], extractBits(val_7, 0u, 1u), 2u, 1u);\n  unpacked[75] = extractBits(val_7, 1u, 3u);\n  unpacked[76] = extractBits(val_7, 4u, 3u);\n  unpacked[77] = extractBits(val_7, 7u, 3u);\n  unpacked[78] = extractBits(val_7, 10u, 3u);\n  unpacked[79] = extractBits(val_7, 13u, 3u);\n  unpacked[80] = extractBits(val_7, 16u, 3u);\n  unpacked[81] = extractBits(val_7, 19u, 3u);\n  unpacked[82] = extractBits(val_7, 22u, 3u);\n  unpacked[83] = extractBits(val_7, 25u, 3u);\n  unpacked[84] = extractBits(val_7, 28u, 3u);\n  unpacked[85] = extractBits(val_7, 31u, 1u);\n  \n  let val_8 = blocks[packed_offset + 8];\n  unpacked[85] = insertBits(unpacked[85], extractBits(val_8, 0u, 2u), 1u, 2u); \n  unpacked[86] = extractBits(val_8, 2u, 3u);\n  unpacked[87] = extractBits(val_8, 5u, 3u);\n  unpacked[88] = extractBits(val_8, 8u, 3u);\n  unpacked[89] = extractBits(val_8, 11u, 3u);\n  unpacked[90] = extractBits(val_8, 14u, 3u);\n  unpacked[91] = extractBits(val_8, 17u, 3u);\n  unpacked[92] = extractBits(val_8, 20u, 3u);\n  unpacked[93] = extractBits(val_8, 23u, 3u);\n  unpacked[94] = extractBits(val_8, 26u, 3u);\n  unpacked[95] = extractBits(val_8, 29u, 3u);\n  \n  let val_9 = blocks[packed_offset + 9];\n  unpacked[96] = extractBits(val_9, 0u, 3u);\n  unpacked[97] = extractBits(val_9, 3u, 3u);\n  unpacked[98] = extractBits(val_9, 6u, 3u);\n  unpacked[99] = extractBits(val_9, 9u, 3u);\n  unpacked[100] = extractBits(val_9, 12u, 3u);\n  unpacked[101] = extractBits(val_9, 15u, 3u);\n  unpacked[102] = extractBits(val_9, 18u, 3u);\n  unpacked[103] = extractBits(val_9, 21u, 3u);\n  unpacked[104] = extractBits(val_9, 24u, 3u);\n  unpacked[105] = extractBits(val_9, 27u, 3u);\n  unpacked[106] = extractBits(val_9, 30u, 2u);\n  \n  let val_10 = blocks[packed_offset + 10];\n  unpacked[106] = insertBits(unpacked[106], extractBits(val_10, 0u, 1u), 2u, 1u);\n  unpacked[107] = extractBits(val_10, 1u, 3u);\n  unpacked[108] = extractBits(val_10, 4u, 3u);\n  unpacked[109] = extractBits(val_10, 7u, 3u);\n  unpacked[110] = extractBits(val_10, 10u, 3u);\n  unpacked[111] = extractBits(val_10, 13u, 3u);\n  unpacked[112] = extractBits(val_10, 16u, 3u);\n  unpacked[113] = extractBits(val_10, 19u, 3u);\n  unpacked[114] = extractBits(val_10, 22u, 3u);\n  unpacked[115] = extractBits(val_10, 25u, 3u);\n  unpacked[116] = extractBits(val_10, 28u, 3u);\n  unpacked[117] = extractBits(val_10, 31u, 1u);\n  \n  let val_11 = blocks[packed_offset + 11];\n  unpacked[117] = insertBits(unpacked[117], extractBits(val_11, 0u, 2u), 1u, 2u); \n  unpacked[118] = extractBits(val_11, 2u, 3u);\n  unpacked[119] = extractBits(val_11, 5u, 3u);\n  unpacked[120] = extractBits(val_11, 8u, 3u);\n  unpacked[121] = extractBits(val_11, 11u, 3u);\n  unpacked[122] = extractBits(val_11, 14u, 3u);\n  unpacked[123] = extractBits(val_11, 17u, 3u);\n  unpacked[124] = extractBits(val_11, 20u, 3u);\n  unpacked[125] = extractBits(val_11, 23u, 3u);\n  unpacked[126] = extractBits(val_11, 26u, 3u);\n  unpacked[127] = extractBits(val_11, 29u, 3u);\n}\n","\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.nbr || global_id.y >= args.nbc) {\n      return;\n  }\n  \n  let blocks_start: u32 = args.blocks_offset + ((global_id.x * args.nbc + global_id.y) * 12u);    \n  unpack_block_128_bit_depth_3(blocks_start);    \n      \n  let b01: u32 = blocks_start;\n  let b2: u32 = blocks_start + 8u;\n  \n  for (var r = 0u; r < ").concat(Ve,"u; r++) {\n    let unpacked_idx = r * ").concat(8,"u;\n    let b01_idx = b01 + (r / 2u);\n    let b2_idx = b2 + (r / 4u);\n\n    blocks[b01_idx] = insertBits(blocks[b01_idx], extractBits(unpacked[unpacked_idx], 0u, 2u), (r * 16u) % 32u, 16u);\n    blocks[b2_idx] = insertBits(blocks[b2_idx], extractBits(unpacked[unpacked_idx], 2u, 1u), (r * 8u) % 32u, 8u);  \n  }\n    \n  for (var c = 1u; c < ").concat(8,"u; c++) {\n    for (var r = 0u; r < ").concat(Ve,"u; r++) {\n      let unpacked_idx = r * ").concat(8,"u + c;\n      let b01_idx = b01 + (r / 2u);\n      let b2_idx = b2 + (r / 4u);\n                \n      blocks[b01_idx] = insertBits(blocks[b01_idx], extractBits(unpacked[unpacked_idx], 0u, 2u), ((r * 16u) % 32u) + (2u * c), 2u);\n      blocks[b2_idx] = insertBits(blocks[b2_idx], extractBits(unpacked[unpacked_idx], 2u, 1u), ((r * 8u) % 32u) + c, 1u);  \n    }\n  }\n}\n\n").concat(I),5:"\n\nstruct argsStruct {\n  nbr: u32,\n  nbc: u32,\n  blocks_offset: u32\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> blocks: array<u32>;\n\n".concat("\nvar<private> unpacked: array<u32, 128>;\n\nfn unpack_block_128_bit_depth_5(packed_offset: u32) {    \n  let val_0 = blocks[packed_offset];\n  unpacked[0] = extractBits(val_0, 0u, 5u);\n  unpacked[1] = extractBits(val_0, 5u, 5u);\n  unpacked[2] = extractBits(val_0, 10u, 5u);\n  unpacked[3] = extractBits(val_0, 15u, 5u);\n  unpacked[4] = extractBits(val_0, 20u, 5u);\n  unpacked[5] = extractBits(val_0, 25u, 5u);\n  unpacked[6] = extractBits(val_0, 30u, 2u);\n  \n  let val_1 = blocks[packed_offset + 1];\n  unpacked[6] = insertBits(unpacked[6], extractBits(val_1, 0u, 3u), 2u, 3u);    \n  unpacked[7] = extractBits(val_1, 3u, 5u);\n  unpacked[8] = extractBits(val_1, 8u, 5u);\n  unpacked[9] = extractBits(val_1, 13u, 5u);\n  unpacked[10] = extractBits(val_1, 18u, 5u);\n  unpacked[11] = extractBits(val_1, 23u, 5u);\n  unpacked[12] = extractBits(val_1, 28u, 4u);\n  \n  let val_2 = blocks[packed_offset + 2];\n  unpacked[12] = insertBits(unpacked[12], extractBits(val_2, 0u, 1u), 4u, 1u);\n  unpacked[13] = extractBits(val_2, 1u, 5u);\n  unpacked[14] = extractBits(val_2, 6u, 5u);\n  unpacked[15] = extractBits(val_2, 11u, 5u);\n  unpacked[16] = extractBits(val_2, 16u, 5u);\n  unpacked[17] = extractBits(val_2, 21u, 5u);\n  unpacked[18] = extractBits(val_2, 26u, 5u);\n  unpacked[19] = extractBits(val_2, 31u, 1u);\n  \n  let val_3 = blocks[packed_offset + 3];\n  unpacked[19] = insertBits(unpacked[19], extractBits(val_3, 0u, 4u), 1u, 4u);\n  unpacked[20] = extractBits(val_3, 4u, 5u);\n  unpacked[21] = extractBits(val_3, 9u, 5u);\n  unpacked[22] = extractBits(val_3, 14u, 5u);\n  unpacked[23] = extractBits(val_3, 19u, 5u);\n  unpacked[24] = extractBits(val_3, 24u, 5u);\n  unpacked[25] = extractBits(val_3, 29u, 3u);\n  \n  let val_4 = blocks[packed_offset + 4];\n  unpacked[25] = insertBits(unpacked[25], extractBits(val_4, 0u, 2u), 3u, 2u);\n  unpacked[26] = extractBits(val_4, 2u, 5u);\n  unpacked[27] = extractBits(val_4, 7u, 5u);\n  unpacked[28] = extractBits(val_4, 12u, 5u);\n  unpacked[29] = extractBits(val_4, 17u, 5u);\n  unpacked[30] = extractBits(val_4, 22u, 5u);\n  unpacked[31] = extractBits(val_4, 27u, 5u);\n  \n  let val_5 = blocks[packed_offset + 5];\n  unpacked[32] = extractBits(val_5, 0u, 5u);\n  unpacked[33] = extractBits(val_5, 5u, 5u);\n  unpacked[34] = extractBits(val_5, 10u, 5u);\n  unpacked[35] = extractBits(val_5, 15u, 5u);\n  unpacked[36] = extractBits(val_5, 20u, 5u);\n  unpacked[37] = extractBits(val_5, 25u, 5u);\n  unpacked[38] = extractBits(val_5, 30u, 2u);\n\n  let val_6 = blocks[packed_offset + 6];\n  unpacked[38] = insertBits(unpacked[38], extractBits(val_6, 0u, 3u), 2u, 3u);\n  unpacked[39] = extractBits(val_6, 3u, 5u);\n  unpacked[40] = extractBits(val_6, 8u, 5u);\n  unpacked[41] = extractBits(val_6, 13u, 5u);\n  unpacked[42] = extractBits(val_6, 18u, 5u);\n  unpacked[43] = extractBits(val_6, 23u, 5u);\n  unpacked[44] = extractBits(val_6, 28u, 4u);\n\n  let val_7 = blocks[packed_offset + 7];\n  unpacked[44] = insertBits(unpacked[44], extractBits(val_7, 0u, 1u), 4u, 1u);\n  unpacked[45] = extractBits(val_7, 1u, 5u);\n  unpacked[46] = extractBits(val_7, 6u, 5u);\n  unpacked[47] = extractBits(val_7, 11u, 5u);\n  unpacked[48] = extractBits(val_7, 16u, 5u);\n  unpacked[49] = extractBits(val_7, 21u, 5u);\n  unpacked[50] = extractBits(val_7, 26u, 5u);\n  unpacked[51] = extractBits(val_7, 31u, 1u);\n\n  let val_8 = blocks[packed_offset + 8];\n  unpacked[51] = insertBits(unpacked[51], extractBits(val_8, 0u, 4u), 1u, 4u);\n  unpacked[52] = extractBits(val_8, 4u, 5u);\n  unpacked[53] = extractBits(val_8, 9u, 5u);\n  unpacked[54] = extractBits(val_8, 14u, 5u);\n  unpacked[55] = extractBits(val_8, 19u, 5u);\n  unpacked[56] = extractBits(val_8, 24u, 5u);\n  unpacked[57] = extractBits(val_8, 29u, 3u);\n  \n  let val_9 = blocks[packed_offset + 9];\n  unpacked[57] = insertBits(unpacked[57], extractBits(val_9, 0u, 2u), 3u, 2u);\n  unpacked[58] = extractBits(val_9, 2u, 5u);\n  unpacked[59] = extractBits(val_9, 7u, 5u);\n  unpacked[60] = extractBits(val_9, 12u, 5u);\n  unpacked[61] = extractBits(val_9, 17u, 5u);\n  unpacked[62] = extractBits(val_9, 22u, 5u);\n  unpacked[63] = extractBits(val_9, 27u, 5u);\n  \n  let val_10 = blocks[packed_offset + 10];\n  unpacked[64] = extractBits(val_10, 0u, 5u);\n  unpacked[65] = extractBits(val_10, 5u, 5u);\n  unpacked[66] = extractBits(val_10, 10u, 5u);\n  unpacked[67] = extractBits(val_10, 15u, 5u);\n  unpacked[68] = extractBits(val_10, 20u, 5u);\n  unpacked[69] = extractBits(val_10, 25u, 5u);\n  unpacked[70] = extractBits(val_10, 30u, 2u);\n\n  let val_11 = blocks[packed_offset + 11];\n  unpacked[70] = insertBits(unpacked[70], extractBits(val_11, 0u, 3u), 2u, 3u);\n  unpacked[71] = extractBits(val_11, 3u, 5u);\n  unpacked[72] = extractBits(val_11, 8u, 5u);\n  unpacked[73] = extractBits(val_11, 13u, 5u);\n  unpacked[74] = extractBits(val_11, 18u, 5u);\n  unpacked[75] = extractBits(val_11, 23u, 5u);\n  unpacked[76] = extractBits(val_11, 28u, 4u);\n\n  let val_12 = blocks[packed_offset + 12];\n  unpacked[76] = insertBits(unpacked[76], extractBits(val_12, 0u, 1u), 4u, 1u);\n  unpacked[77] = extractBits(val_12, 1u, 5u);\n  unpacked[78] = extractBits(val_12, 6u, 5u);\n  unpacked[79] = extractBits(val_12, 11u, 5u);\n  unpacked[80] = extractBits(val_12, 16u, 5u);\n  unpacked[81] = extractBits(val_12, 21u, 5u);\n  unpacked[82] = extractBits(val_12, 26u, 5u);\n  unpacked[83] = extractBits(val_12, 31u, 1u);\n\n  let val_13 = blocks[packed_offset + 13];\n  unpacked[83] = insertBits(unpacked[83], extractBits(val_13, 0u, 4u), 1u, 4u);\n  unpacked[84] = extractBits(val_13, 4u, 5u);\n  unpacked[85] = extractBits(val_13, 9u, 5u);\n  unpacked[86] = extractBits(val_13, 14u, 5u);\n  unpacked[87] = extractBits(val_13, 19u, 5u);\n  unpacked[88] = extractBits(val_13, 24u, 5u);\n  unpacked[89] = extractBits(val_13, 29u, 3u);\n  \n  let val_14 = blocks[packed_offset + 14];\n  unpacked[89] = insertBits(unpacked[89], extractBits(val_14, 0u, 2u), 3u, 2u);\n  unpacked[90] = extractBits(val_14, 2u, 5u);\n  unpacked[91] = extractBits(val_14, 7u, 5u);\n  unpacked[92] = extractBits(val_14, 12u, 5u);\n  unpacked[93] = extractBits(val_14, 17u, 5u);\n  unpacked[94] = extractBits(val_14, 22u, 5u);\n  unpacked[95] = extractBits(val_14, 27u, 5u);\n\n  let val_15 = blocks[packed_offset + 15];\n  unpacked[96] = extractBits(val_15, 0u, 5u);\n  unpacked[97] = extractBits(val_15, 5u, 5u);\n  unpacked[98] = extractBits(val_15, 10u, 5u);\n  unpacked[99] = extractBits(val_15, 15u, 5u);\n  unpacked[100] = extractBits(val_15, 20u, 5u);\n  unpacked[101] = extractBits(val_15, 25u, 5u);\n  unpacked[102] = extractBits(val_15, 30u, 2u);\n\n  let val_16 = blocks[packed_offset + 16];\n  unpacked[102] = insertBits(unpacked[102], extractBits(val_16, 0u, 3u), 2u, 3u);\n  unpacked[103] = extractBits(val_16, 3u, 5u);\n  unpacked[104] = extractBits(val_16, 8u, 5u);\n  unpacked[105] = extractBits(val_16, 13u, 5u);\n  unpacked[106] = extractBits(val_16, 18u, 5u);\n  unpacked[107] = extractBits(val_16, 23u, 5u);\n  unpacked[108] = extractBits(val_16, 28u, 4u);\n\n  let val_17 = blocks[packed_offset + 17];\n  unpacked[108] = insertBits(unpacked[108], extractBits(val_17, 0u, 1u), 4u, 1u);\n  unpacked[109] = extractBits(val_17, 1u, 5u);\n  unpacked[110] = extractBits(val_17, 6u, 5u);\n  unpacked[111] = extractBits(val_17, 11u, 5u);\n  unpacked[112] = extractBits(val_17, 16u, 5u);\n  unpacked[113] = extractBits(val_17, 21u, 5u);\n  unpacked[114] = extractBits(val_17, 26u, 5u);\n  unpacked[115] = extractBits(val_17, 31u, 1u);\n  \n  let val_18 = blocks[packed_offset + 18];\n  unpacked[115] = insertBits(unpacked[115], extractBits(val_18, 0u, 4u), 1u, 4u);\n  unpacked[116] = extractBits(val_18, 4u, 5u);\n  unpacked[117] = extractBits(val_18, 9u, 5u);\n  unpacked[118] = extractBits(val_18, 14u, 5u);\n  unpacked[119] = extractBits(val_18, 19u, 5u);\n  unpacked[120] = extractBits(val_18, 24u, 5u);\n  unpacked[121] = extractBits(val_18, 29u, 3u);\n\n  let val_19 = blocks[packed_offset + 19];\n  unpacked[121] = insertBits(unpacked[121], extractBits(val_19, 0u, 2u), 3u, 2u);\n  unpacked[122] = extractBits(val_19, 2u, 5u);\n  unpacked[123] = extractBits(val_19, 7u, 5u);\n  unpacked[124] = extractBits(val_19, 12u, 5u);\n  unpacked[125] = extractBits(val_19, 17u, 5u);\n  unpacked[126] = extractBits(val_19, 22u, 5u);\n  unpacked[127] = extractBits(val_19, 27u, 5u);\n}\n","\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.nbr || global_id.y >= args.nbc) {\n      return;\n  }\n\n  let blocks_start: u32 = args.blocks_offset + ((global_id.x * args.nbc + global_id.y) * 20u);\n  unpack_block_128_bit_depth_5(blocks_start);    \n  \n  let b03: u32 = blocks_start;\n  let b4: u32 = blocks_start + 16u;\n\n  for (var r = 0u; r < ").concat(Ve,"u; r++) {\n    let unpacked_idx = r * ").concat(8,"u;\n    let b03_idx = b03 + r;\n    let b4_idx = b4 + (r / 4u);\n          \n    blocks[b03_idx] = insertBits(blocks[b03_idx], extractBits(unpacked[unpacked_idx], 0u, 4u), 0u, 32u);\n    blocks[b4_idx] = insertBits(blocks[b4_idx], extractBits(unpacked[unpacked_idx], 4u, 1u), (r * 8u) % 32u, 8u);\n  }\n      \n  for (var c = 1u; c < ").concat(8,"u; c++) {\n    for (var r = 0u; r < ").concat(Ve,"u; r++) {\n      let unpacked_idx = r * ").concat(8,"u + c;\n      let b03_idx = b03 + r;\n      let b4_idx = b4 + (r / 4u);\n                                \n      blocks[b03_idx] = insertBits(blocks[b03_idx], extractBits(unpacked[unpacked_idx], 0u, 4u), 4 * c, 4u);\n      blocks[b4_idx] = insertBits(blocks[b4_idx], extractBits(unpacked[unpacked_idx], 4u, 1u), ((r * 8u) % 32u) + c, 1u);\n    }\n  }   \n}\n\n").concat(I),6:"\n\nstruct argsStruct {\n  nbr: u32,\n  nbc: u32,\n  blocks_offset: u32\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> blocks: array<u32>;\n\n".concat("\nvar<private> unpacked: array<u32, 128>;\n\nfn unpack_block_128_bit_depth_6(packed_offset: u32) {\n  let val_0 = blocks[packed_offset];\n  unpacked[0] = extractBits(val_0, 0u, 6u);\n  unpacked[1] = extractBits(val_0, 6u, 6u);\n  unpacked[2] = extractBits(val_0, 12u, 6u);\n  unpacked[3] = extractBits(val_0, 18u, 6u);\n  unpacked[4] = extractBits(val_0, 24u, 6u);\n  unpacked[5] = extractBits(val_0, 30u, 2u);\n  \n  let val_1 = blocks[packed_offset + 1];\n  unpacked[5] = insertBits(unpacked[5], extractBits(val_1, 0u, 4u), 2u, 4u);\n  unpacked[6] = extractBits(val_1, 4u, 6u);\n  unpacked[7] = extractBits(val_1, 10u, 6u);\n  unpacked[8] = extractBits(val_1, 16u, 6u);\n  unpacked[9] = extractBits(val_1, 22u, 6u);\n  unpacked[10] = extractBits(val_1, 28u, 4u);\n  \n  let val_2 = blocks[packed_offset + 2];\n  unpacked[10] = insertBits(unpacked[10], extractBits(val_2, 0u, 2u), 4u, 2u);\n  unpacked[11] = extractBits(val_2, 2u, 6u);\n  unpacked[12] = extractBits(val_2, 8u, 6u);\n  unpacked[13] = extractBits(val_2, 14u, 6u);\n  unpacked[14] = extractBits(val_2, 20u, 6u);\n  unpacked[15] = extractBits(val_2, 26u, 6u);\n  \n  let val_3 = blocks[packed_offset + 3];\n  unpacked[16] = extractBits(val_3, 0u, 6u);\n  unpacked[17] = extractBits(val_3, 6u, 6u);\n  unpacked[18] = extractBits(val_3, 12u, 6u);\n  unpacked[19] = extractBits(val_3, 18u, 6u);\n  unpacked[20] = extractBits(val_3, 24u, 6u);\n  unpacked[21] = extractBits(val_3, 30u, 2u);\n  \n  let val_4 = blocks[packed_offset + 4];\n  unpacked[21] = insertBits(unpacked[21], extractBits(val_4, 0u, 4u), 2u, 4u);\n  unpacked[22] = extractBits(val_4, 4u, 6u);\n  unpacked[23] = extractBits(val_4, 10u, 6u);\n  unpacked[24] = extractBits(val_4, 16u, 6u);\n  unpacked[25] = extractBits(val_4, 22u, 6u);\n  unpacked[26] = extractBits(val_4, 28u, 4u);\n\n  let val_5 = blocks[packed_offset + 5];\n  unpacked[26] = insertBits(unpacked[26], extractBits(val_5, 0u, 2u), 4u, 2u);\n  unpacked[27] = extractBits(val_5, 2u, 6u);\n  unpacked[28] = extractBits(val_5, 8u, 6u);\n  unpacked[29] = extractBits(val_5, 14u, 6u);\n  unpacked[30] = extractBits(val_5, 20u, 6u);\n  unpacked[31] = extractBits(val_5, 26u, 6u);\n\n  let val_6 = blocks[packed_offset + 6];\n  unpacked[32] = extractBits(val_6, 0u, 6u);\n  unpacked[33] = extractBits(val_6, 6u, 6u);\n  unpacked[34] = extractBits(val_6, 12u, 6u);\n  unpacked[35] = extractBits(val_6, 18u, 6u);\n  unpacked[36] = extractBits(val_6, 24u, 6u);\n  unpacked[37] = extractBits(val_6, 30u, 2u);\n\n  let val_7 = blocks[packed_offset + 7];\n  unpacked[37] = insertBits(unpacked[37], extractBits(val_7, 0u, 4u), 2u, 4u);\n  unpacked[38] = extractBits(val_7, 4u, 6u);\n  unpacked[39] = extractBits(val_7, 10u, 6u);\n  unpacked[40] = extractBits(val_7, 16u, 6u);\n  unpacked[41] = extractBits(val_7, 22u, 6u);\n  unpacked[42] = extractBits(val_7, 28u, 4u);\n  \n  let val_8 = blocks[packed_offset + 8];\n  unpacked[42] = insertBits(unpacked[42], extractBits(val_8, 0u, 2u), 4u, 2u);\n  unpacked[43] = extractBits(val_8, 2u, 6u);\n  unpacked[44] = extractBits(val_8, 8u, 6u);\n  unpacked[45] = extractBits(val_8, 14u, 6u);\n  unpacked[46] = extractBits(val_8, 20u, 6u);\n  unpacked[47] = extractBits(val_8, 26u, 6u);\n\n  let val_9 = blocks[packed_offset + 9];\n  unpacked[48] = extractBits(val_9, 0u, 6u);\n  unpacked[49] = extractBits(val_9, 6u, 6u);\n  unpacked[50] = extractBits(val_9, 12u, 6u);\n  unpacked[51] = extractBits(val_9, 18u, 6u);\n  unpacked[52] = extractBits(val_9, 24u, 6u);\n  unpacked[53] = extractBits(val_9, 30u, 2u);\n\n  let val_10 = blocks[packed_offset + 10];\n  unpacked[53] = insertBits(unpacked[53], extractBits(val_10, 0u, 4u), 2u, 4u);\n  unpacked[54] = extractBits(val_10, 4u, 6u);\n  unpacked[55] = extractBits(val_10, 10u, 6u);\n  unpacked[56] = extractBits(val_10, 16u, 6u);\n  unpacked[57] = extractBits(val_10, 22u, 6u);\n  unpacked[58] = extractBits(val_10, 28u, 4u);\n\n  let val_11 = blocks[packed_offset + 11];\n  unpacked[58] = insertBits(unpacked[58], extractBits(val_11, 0u, 2u), 4u, 2u);\n  unpacked[59] = extractBits(val_11, 2u, 6u);\n  unpacked[60] = extractBits(val_11, 8u, 6u);\n  unpacked[61] = extractBits(val_11, 14u, 6u);\n  unpacked[62] = extractBits(val_11, 20u, 6u);\n  unpacked[63] = extractBits(val_11, 26u, 6u);\n  \n  let val_12 = blocks[packed_offset + 12];\n  unpacked[64] = extractBits(val_12, 0u, 6u);\n  unpacked[65] = extractBits(val_12, 6u, 6u);\n  unpacked[66] = extractBits(val_12, 12u, 6u);\n  unpacked[67] = extractBits(val_12, 18u, 6u);\n  unpacked[68] = extractBits(val_12, 24u, 6u);\n  unpacked[69] = extractBits(val_12, 30u, 2u);\n\n  let val_13 = blocks[packed_offset + 13];\n  unpacked[69] = insertBits(unpacked[69], extractBits(val_13, 0u, 4u), 2u, 4u);\n  unpacked[70] = extractBits(val_13, 4u, 6u);\n  unpacked[71] = extractBits(val_13, 10u, 6u);\n  unpacked[72] = extractBits(val_13, 16u, 6u);\n  unpacked[73] = extractBits(val_13, 22u, 6u);\n  unpacked[74] = extractBits(val_13, 28u, 4u);\n\n  let val_14 = blocks[packed_offset + 14];\n  unpacked[74] = insertBits(unpacked[74], extractBits(val_14, 0u, 2u), 4u, 2u);\n  unpacked[75] = extractBits(val_14, 2u, 6u);\n  unpacked[76] = extractBits(val_14, 8u, 6u);\n  unpacked[77] = extractBits(val_14, 14u, 6u);\n  unpacked[78] = extractBits(val_14, 20u, 6u);\n  unpacked[79] = extractBits(val_14, 26u, 6u);\n\n  let val_15 = blocks[packed_offset + 15];\n  unpacked[80] = extractBits(val_15, 0u, 6u);\n  unpacked[81] = extractBits(val_15, 6u, 6u);\n  unpacked[82] = extractBits(val_15, 12u, 6u);\n  unpacked[83] = extractBits(val_15, 18u, 6u);\n  unpacked[84] = extractBits(val_15, 24u, 6u);\n  unpacked[85] = extractBits(val_15, 30u, 2u);\n  \n  let val_16 = blocks[packed_offset + 16];\n  unpacked[85] = insertBits(unpacked[85], extractBits(val_16, 0u, 4u), 2u, 4u);\n  unpacked[86] = extractBits(val_16, 4u, 6u);\n  unpacked[87] = extractBits(val_16, 10u, 6u);\n  unpacked[88] = extractBits(val_16, 16u, 6u);\n  unpacked[89] = extractBits(val_16, 22u, 6u);\n  unpacked[90] = extractBits(val_16, 28u, 4u);\n\n  let val_17 = blocks[packed_offset + 17];\n  unpacked[90] = insertBits(unpacked[90], extractBits(val_17, 0u, 2u), 4u, 2u);\n  unpacked[91] = extractBits(val_17, 2u, 6u);\n  unpacked[92] = extractBits(val_17, 8u, 6u);\n  unpacked[93] = extractBits(val_17, 14u, 6u);\n  unpacked[94] = extractBits(val_17, 20u, 6u);\n  unpacked[95] = extractBits(val_17, 26u, 6u);\n\n  let val_18 = blocks[packed_offset + 18];\n  unpacked[96] = extractBits(val_18, 0u, 6u);\n  unpacked[97] = extractBits(val_18, 6u, 6u);\n  unpacked[98] = extractBits(val_18, 12u, 6u);\n  unpacked[99] = extractBits(val_18, 18u, 6u);\n  unpacked[100] = extractBits(val_18, 24u, 6u);\n  unpacked[101] = extractBits(val_18, 30u, 2u);\n\n  let val_19 = blocks[packed_offset + 19];\n  unpacked[101] = insertBits(unpacked[101], extractBits(val_19, 0u, 4u), 2u, 4u);\n  unpacked[102] = extractBits(val_19, 4u, 6u);\n  unpacked[103] = extractBits(val_19, 10u, 6u);\n  unpacked[104] = extractBits(val_19, 16u, 6u);\n  unpacked[105] = extractBits(val_19, 22u, 6u);\n  unpacked[106] = extractBits(val_19, 28u, 4u);\n  \n  let val_20 = blocks[packed_offset + 20];\n  unpacked[106] = insertBits(unpacked[106], extractBits(val_20, 0u, 2u), 4u, 2u);\n  unpacked[107] = extractBits(val_20, 2u, 6u);\n  unpacked[108] = extractBits(val_20, 8u, 6u);\n  unpacked[109] = extractBits(val_20, 14u, 6u);\n  unpacked[110] = extractBits(val_20, 20u, 6u);\n  unpacked[111] = extractBits(val_20, 26u, 6u);\n\n  let val_21 = blocks[packed_offset + 21];\n  unpacked[112] = extractBits(val_21, 0u, 6u);\n  unpacked[113] = extractBits(val_21, 6u, 6u);\n  unpacked[114] = extractBits(val_21, 12u, 6u);\n  unpacked[115] = extractBits(val_21, 18u, 6u);\n  unpacked[116] = extractBits(val_21, 24u, 6u);\n  unpacked[117] = extractBits(val_21, 30u, 2u);\n\n  let val_22 = blocks[packed_offset + 22];\n  unpacked[117] = insertBits(unpacked[117], extractBits(val_22, 0u, 4u), 2u, 4u);\n  unpacked[118] = extractBits(val_22, 4u, 6u);\n  unpacked[119] = extractBits(val_22, 10u, 6u);\n  unpacked[120] = extractBits(val_22, 16u, 6u);\n  unpacked[121] = extractBits(val_22, 22u, 6u);\n  unpacked[122] = extractBits(val_22, 28u, 4u);\n\n  let val_23 = blocks[packed_offset + 23];\n  unpacked[122] = insertBits(unpacked[122], extractBits(val_23, 0u, 2u), 4u, 2u);\n  unpacked[123] = extractBits(val_23, 2u, 6u);\n  unpacked[124] = extractBits(val_23, 8u, 6u);\n  unpacked[125] = extractBits(val_23, 14u, 6u);\n  unpacked[126] = extractBits(val_23, 20u, 6u);\n  unpacked[127] = extractBits(val_23, 26u, 6u);\n}\n","\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.nbr || global_id.y >= args.nbc) {\n      return;\n  }\n  \n  let blocks_start: u32 = args.blocks_offset + ((global_id.x * args.nbc + global_id.y) * 24u);\n  unpack_block_128_bit_depth_6(blocks_start);\n  \n  let b03: u32 = blocks_start;\n  let b45: u32 = blocks_start + 16u;    \n  for (var r = 0u; r < ").concat(Ve,"u; r++) {\n    let unpacked_idx = r * ").concat(8,"u;\n    let b03_idx = b03 + r;\n    let b45_idx = b45 + (r / 2u);\n    \n    blocks[b03_idx] = insertBits(blocks[b03_idx], extractBits(unpacked[unpacked_idx], 0u, 4u), 0u, 32u);\n    blocks[b45_idx] = insertBits(blocks[b45_idx], extractBits(unpacked[unpacked_idx], 4u, 2u), ((r * 16u) % 32u), 16u);\n  }\n\n  for (var c = 1u; c < ").concat(8,"u; c++) {\n    for (var r = 0u; r < ").concat(Ve,"u; r++) {\n      let unpacked_idx = r * ").concat(8,"u + c;\n      let b03_idx = b03 + r;\n      let b45_idx = b45 + (r / 2u);\n      \n      blocks[b03_idx] = insertBits(blocks[b03_idx], extractBits(unpacked[unpacked_idx], 0u, 4u), 4 * c, 4u);\n      blocks[b45_idx] = insertBits(blocks[b45_idx], extractBits(unpacked[unpacked_idx], 4u, 2u), ((r * 16u) % 32u) + (2 * c), 2u);\n    }\n  }\n}\n\n").concat(I),7:"\n\nstruct argsStruct {\n  nbr: u32,\n  nbc: u32,\n  blocks_offset: u32\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> blocks: array<u32>;\n\n".concat("\nvar<private> unpacked: array<u32, 128>;\n\nfn unpack_block_128_bit_depth_7(packed_offset: u32) {\n  let val_0 = blocks[packed_offset];\n  unpacked[0] = extractBits(val_0, 0u, 7u);\n  unpacked[1] = extractBits(val_0, 7u, 7u);\n  unpacked[2] = extractBits(val_0, 14u, 7u);\n  unpacked[3] = extractBits(val_0, 21u, 7u);\n  unpacked[4] = extractBits(val_0, 28u, 4u);\n  \n  let val_1 = blocks[packed_offset + 1];\n  unpacked[4] = insertBits(unpacked[4], extractBits(val_1, 0u, 3u), 4u, 3u);\n  unpacked[5] = extractBits(val_1, 3u, 7u);\n  unpacked[6] = extractBits(val_1, 10u, 7u);\n  unpacked[7] = extractBits(val_1, 17u, 7u);\n  unpacked[8] = extractBits(val_1, 24u, 7u);\n  unpacked[9] = extractBits(val_1, 31u, 1u);\n  \n  let val_2 = blocks[packed_offset + 2];\n  unpacked[9] = insertBits(unpacked[9], extractBits(val_2, 0u, 6u), 1u, 6u);\n  unpacked[10] = extractBits(val_2, 6u, 7u);\n  unpacked[11] = extractBits(val_2, 13u, 7u);\n  unpacked[12] = extractBits(val_2, 20u, 7u);\n  unpacked[13] = extractBits(val_2, 27u, 5u);\n  \n  let val_3 = blocks[packed_offset + 3];\n  unpacked[13] = insertBits(unpacked[13], extractBits(val_3, 0u, 2u), 5u, 2u);\n  unpacked[14] = extractBits(val_3, 2u, 7u);\n  unpacked[15] = extractBits(val_3, 9u, 7u);\n  unpacked[16] = extractBits(val_3, 16u, 7u);\n  unpacked[17] = extractBits(val_3, 23u, 7u);\n  unpacked[18] = extractBits(val_3, 30u, 2u);\n  \n  let val_4 = blocks[packed_offset + 4];\n  unpacked[18] = insertBits(unpacked[18], extractBits(val_4, 0u, 5u), 2u, 5u);\n  unpacked[19] = extractBits(val_4, 5u, 7u);\n  unpacked[20] = extractBits(val_4, 12u, 7u);\n  unpacked[21] = extractBits(val_4, 19u, 7u);\n  unpacked[22] = extractBits(val_4, 26u, 6u);\n  \n  let val_5 = blocks[packed_offset + 5];\n  unpacked[22] = insertBits(unpacked[22], extractBits(val_5, 0u, 1u), 6u, 1u);\n  unpacked[23] = extractBits(val_5, 1u, 7u);\n  unpacked[24] = extractBits(val_5, 8u, 7u);\n  unpacked[25] = extractBits(val_5, 15u, 7u);\n  unpacked[26] = extractBits(val_5, 22u, 7u);\n  unpacked[27] = extractBits(val_5, 29u, 3u);\n  \n  let val_6 = blocks[packed_offset + 6];\n  unpacked[27] = insertBits(unpacked[27], extractBits(val_6, 0u, 4u), 3u, 4u);\n  unpacked[28] = extractBits(val_6, 4u, 7u);\n  unpacked[29] = extractBits(val_6, 11u, 7u);\n  unpacked[30] = extractBits(val_6, 18u, 7u);\n  unpacked[31] = extractBits(val_6, 25u, 7u);\n  \n  let val_7 = blocks[packed_offset + 7];\n  unpacked[32] = extractBits(val_7, 0u, 7u);\n  unpacked[33] = extractBits(val_7, 7u, 7u);\n  unpacked[34] = extractBits(val_7, 14u, 7u);\n  unpacked[35] = extractBits(val_7, 21u, 7u);\n  unpacked[36] = extractBits(val_7, 28u, 4u);\n  \n  let val_8 = blocks[packed_offset + 8];\n  unpacked[36] = insertBits(unpacked[36], extractBits(val_8, 0u, 3u), 4u, 3u);\n  unpacked[37] = extractBits(val_8, 3u, 7u);\n  unpacked[38] = extractBits(val_8, 10u, 7u);\n  unpacked[39] = extractBits(val_8, 17u, 7u);\n  unpacked[40] = extractBits(val_8, 24u, 7u);\n  unpacked[41] = extractBits(val_8, 31u, 1u);\n  \n  let val_9 = blocks[packed_offset + 9];\n  unpacked[41] = insertBits(unpacked[41], extractBits(val_9, 0u, 6u), 1u, 6u);\n  unpacked[42] = extractBits(val_9, 6u, 7u);\n  unpacked[43] = extractBits(val_9, 13u, 7u);\n  unpacked[44] = extractBits(val_9, 20u, 7u);\n  unpacked[45] = extractBits(val_9, 27u, 5u);\n  \n  let val_10 = blocks[packed_offset + 10];\n  unpacked[45] = insertBits(unpacked[45], extractBits(val_10, 0u, 2u), 5u, 2u);\n  unpacked[46] = extractBits(val_10, 2u, 7u);\n  unpacked[47] = extractBits(val_10, 9u, 7u);\n  unpacked[48] = extractBits(val_10, 16u, 7u);\n  unpacked[49] = extractBits(val_10, 23u, 7u);\n  unpacked[50] = extractBits(val_10, 30u, 2u);\n  \n  let val_11 = blocks[packed_offset + 11];\n  unpacked[50] = insertBits(unpacked[50], extractBits(val_11, 0u, 5u), 2u, 5u);\n  unpacked[51] = extractBits(val_11, 5u, 7u);\n  unpacked[52] = extractBits(val_11, 12u, 7u);\n  unpacked[53] = extractBits(val_11, 19u, 7u);\n  unpacked[54] = extractBits(val_11, 26u, 6u);\n  \n  let val_12 = blocks[packed_offset + 12];\n  unpacked[54] = insertBits(unpacked[54], extractBits(val_12, 0u, 1u), 6u, 1u);\n  unpacked[55] = extractBits(val_12, 1u, 7u);\n  unpacked[56] = extractBits(val_12, 8u, 7u);\n  unpacked[57] = extractBits(val_12, 15u, 7u);\n  unpacked[58] = extractBits(val_12, 22u, 7u);\n  unpacked[59] = extractBits(val_12, 29u, 3u);\n  \n  let val_13 = blocks[packed_offset + 13];\n  unpacked[59] = insertBits(unpacked[59], extractBits(val_13, 0u, 4u), 3u, 4u);\n  unpacked[60] = extractBits(val_13, 4u, 7u);\n  unpacked[61] = extractBits(val_13, 11u, 7u);\n  unpacked[62] = extractBits(val_13, 18u, 7u);\n  unpacked[63] = extractBits(val_13, 25u, 7u);\n  \n  let val_14 = blocks[packed_offset + 14];\n  unpacked[64] = extractBits(val_14, 0u, 7u);\n  unpacked[65] = extractBits(val_14, 7u, 7u);\n  unpacked[66] = extractBits(val_14, 14u, 7u);\n  unpacked[67] = extractBits(val_14, 21u, 7u);\n  unpacked[68] = extractBits(val_14, 28u, 4u);\n  \n  let val_15 = blocks[packed_offset + 15];\n  unpacked[68] = insertBits(unpacked[68], extractBits(val_15, 0u, 3u), 4u, 3u);\n  unpacked[69] = extractBits(val_15, 3u, 7u);\n  unpacked[70] = extractBits(val_15, 10u, 7u);\n  unpacked[71] = extractBits(val_15, 17u, 7u);\n  unpacked[72] = extractBits(val_15, 24u, 7u);\n  unpacked[73] = extractBits(val_15, 31u, 1u);\n  \n  let val_16 = blocks[packed_offset + 16];\n  unpacked[73] = insertBits(unpacked[73], extractBits(val_16, 0u, 6u), 1u, 6u);\n  unpacked[74] = extractBits(val_16, 6u, 7u);\n  unpacked[75] = extractBits(val_16, 13u, 7u);\n  unpacked[76] = extractBits(val_16, 20u, 7u);\n  unpacked[77] = extractBits(val_16, 27u, 5u);\n  \n  let val_17 = blocks[packed_offset + 17];\n  unpacked[77] = insertBits(unpacked[77], extractBits(val_17, 0u, 2u), 5u, 2u);\n  unpacked[78] = extractBits(val_17, 2u, 7u);\n  unpacked[79] = extractBits(val_17, 9u, 7u);\n  unpacked[80] = extractBits(val_17, 16u, 7u);\n  unpacked[81] = extractBits(val_17, 23u, 7u);\n  unpacked[82] = extractBits(val_17, 30u, 2u);\n  \n  let val_18 = blocks[packed_offset + 18];\n  unpacked[82] = insertBits(unpacked[82], extractBits(val_18, 0u, 5u), 2u, 5u);\n  unpacked[83] = extractBits(val_18, 5u, 7u);\n  unpacked[84] = extractBits(val_18, 12u, 7u);\n  unpacked[85] = extractBits(val_18, 19u, 7u);\n  unpacked[86] = extractBits(val_18, 26u, 6u);\n  \n  let val_19 = blocks[packed_offset + 19];\n  unpacked[86] = insertBits(unpacked[86], extractBits(val_19, 0u, 1u), 6u, 1u);\n  unpacked[87] = extractBits(val_19, 1u, 7u);\n  unpacked[88] = extractBits(val_19, 8u, 7u);\n  unpacked[89] = extractBits(val_19, 15u, 7u);\n  unpacked[90] = extractBits(val_19, 22u, 7u);\n  unpacked[91] = extractBits(val_19, 29u, 3u);\n  \n  let val_20 = blocks[packed_offset + 20];\n  unpacked[91] = insertBits(unpacked[91], extractBits(val_20, 0u, 4u), 3u, 4u);\n  unpacked[92] = extractBits(val_20, 4u, 7u);\n  unpacked[93] = extractBits(val_20, 11u, 7u);\n  unpacked[94] = extractBits(val_20, 18u, 7u);\n  unpacked[95] = extractBits(val_20, 25u, 7u);\n  \n  let val_21 = blocks[packed_offset + 21];\n  unpacked[96] = extractBits(val_21, 0u, 7u);\n  unpacked[97] = extractBits(val_21, 7u, 7u);\n  unpacked[98] = extractBits(val_21, 14u, 7u);\n  unpacked[99] = extractBits(val_21, 21u, 7u);\n  unpacked[100] = extractBits(val_21, 28u, 4u);\n  \n  let val_22 = blocks[packed_offset + 22];\n  unpacked[100] = insertBits(unpacked[100], extractBits(val_22, 0u, 3u), 4u, 3u);\n  unpacked[101] = extractBits(val_22, 3u, 7u);\n  unpacked[102] = extractBits(val_22, 10u, 7u);\n  unpacked[103] = extractBits(val_22, 17u, 7u);\n  unpacked[104] = extractBits(val_22, 24u, 7u);\n  unpacked[105] = extractBits(val_22, 31u, 1u);\n  \n  let val_23 = blocks[packed_offset + 23];\n  unpacked[105] = insertBits(unpacked[105], extractBits(val_23, 0u, 6u), 1u, 6u);\n  unpacked[106] = extractBits(val_23, 6u, 7u);\n  unpacked[107] = extractBits(val_23, 13u, 7u);\n  unpacked[108] = extractBits(val_23, 20u, 7u);\n  unpacked[109] = extractBits(val_23, 27u, 5u);\n  \n  let val_24 = blocks[packed_offset + 24];\n  unpacked[109] = insertBits(unpacked[109], extractBits(val_24, 0u, 2u), 5u, 2u);\n  unpacked[110] = extractBits(val_24, 2u, 7u);\n  unpacked[111] = extractBits(val_24, 9u, 7u);\n  unpacked[112] = extractBits(val_24, 16u, 7u);\n  unpacked[113] = extractBits(val_24, 23u, 7u);\n  unpacked[114] = extractBits(val_24, 30u, 2u);\n  \n  let val_25 = blocks[packed_offset + 25];\n  unpacked[114] = insertBits(unpacked[114], extractBits(val_25, 0u, 5u), 2u, 5u);\n  unpacked[115] = extractBits(val_25, 5u, 7u);\n  unpacked[116] = extractBits(val_25, 12u, 7u);\n  unpacked[117] = extractBits(val_25, 19u, 7u);\n  unpacked[118] = extractBits(val_25, 26u, 6u);\n  \n  let val_26 = blocks[packed_offset + 26];\n  unpacked[118] = insertBits(unpacked[118], extractBits(val_26, 0u, 1u), 6u, 1u);\n  unpacked[119] = extractBits(val_26, 1u, 7u);\n  unpacked[120] = extractBits(val_26, 8u, 7u);\n  unpacked[121] = extractBits(val_26, 15u, 7u);\n  unpacked[122] = extractBits(val_26, 22u, 7u);\n  unpacked[123] = extractBits(val_26, 29u, 3u);\n  \n  let val_27 = blocks[packed_offset + 27];\n  unpacked[123] = insertBits(unpacked[123], extractBits(val_27, 0u, 4u), 3u, 4u);\n  unpacked[124] = extractBits(val_27, 4u, 7u);\n  unpacked[125] = extractBits(val_27, 11u, 7u);\n  unpacked[126] = extractBits(val_27, 18u, 7u);\n  unpacked[127] = extractBits(val_27, 25u, 7u);    \n}\n","\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.nbr || global_id.y >= args.nbc) {\n      return;\n  }\n  \n  let blocks_start: u32 = args.blocks_offset + ((global_id.x * args.nbc + global_id.y) * 28u);\n  unpack_block_128_bit_depth_7(blocks_start);\n  \n  let b03: u32 = blocks_start;\n  let b45: u32 = blocks_start + 16u;\n  let b6: u32 = blocks_start + 24u;  \n  for (var r = 0u; r < ").concat(Ve,"u; r++) {\n    let unpacked_idx = r * ").concat(8,"u;\n    let b03_idx = b03 + r;\n    let b45_idx = b45 + (r / 2u);\n    let b6_idx = b6 + (r / 4u);\n    \n    blocks[b03_idx] = insertBits(blocks[b03_idx], extractBits(unpacked[unpacked_idx], 0u, 4u), 0, 32u);\n    blocks[b45_idx] = insertBits(blocks[b45_idx], extractBits(unpacked[unpacked_idx], 4u, 2u), ((r * 16u) % 32u), 16u);\n    blocks[b6_idx] = insertBits(blocks[b6_idx], extractBits(unpacked[unpacked_idx], 6u, 1u), ((r * 8u) % 32u), 8u);\n  }\n  \n  for (var c = 1u; c < ").concat(8,"u; c++) {\n    for (var r = 0u; r < ").concat(Ve,"u; r++) {\n      let unpacked_idx = r * ").concat(8,"u + c;\n      let b03_idx = b03 + r;\n      let b45_idx = b45 + (r / 2u);\n      let b6_idx = b6 + (r / 4u);\n      \n      blocks[b03_idx] = insertBits(blocks[b03_idx], extractBits(unpacked[unpacked_idx], 0u, 4u), 4 * c, 4u);\n      blocks[b45_idx] = insertBits(blocks[b45_idx], extractBits(unpacked[unpacked_idx], 4u, 2u), ((r * 16u) % 32u) + (2 * c), 2u);\n      blocks[b6_idx] = insertBits(blocks[b6_idx], extractBits(unpacked[unpacked_idx], 6u, 1u), ((r * 8u) % 32u) + c, 1u);\n    }\n  }\n}\n\n").concat(I)},Qe={3:"pv_picollm_weight_block_mixed_16x8_preprocess_blocks_3bit_shader",5:"pv_picollm_weight_block_mixed_16x8_preprocess_blocks_5bit_shader",6:"pv_picollm_weight_block_mixed_16x8_preprocess_blocks_6bit_shader",7:"pv_picollm_weight_block_mixed_16x8_preprocess_blocks_7bit_shader"},Xe="\nconst BM = ".concat(8,"u;\nconst BN = ").concat(32,"u;\n\nconst TM = ").concat(2,"u;\nconst TN = ").concat(16,"u;\n\nconst TC = ").concat(128,"u;\n\nconst ROW_PER_BLOCK = ").concat(Ve,"u;\nconst COL_PER_BLOCK = ").concat(8,"u;\n\nconst VEC_COL_PER_BLOCK = COL_PER_BLOCK / 4u;\n\nconst block_size: u32 = (COL_PER_BLOCK * ROW_PER_BLOCK * bit_depth) / 32u;\n\n"),He={1:"\n  let b0 = blocks[src + (row / 4u)];\n\n  let b0_offset_base = (row * 8u) % 32u;\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    let b0_offset = b0_offset_base + (c * 4u); \n    shared_w[dst + c] = vec4(\n      f32(extractBits(b0, b0_offset, 1u)), \n      f32(extractBits(b0, b0_offset + 1, 1u)),\n      f32(extractBits(b0, b0_offset + 2, 1u)),\n      f32(extractBits(b0, b0_offset + 3, 1u)));\n  }\n",2:"\n  let b01 = blocks[src + (row / 2u)];\n \n  let b01_offset_base = (row * 16u) % 32u;\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {  \n    let b01_offset = b01_offset_base + (c * 8u);\n    shared_w[dst + c] = vec4(\n      f32(extractBits(b01, b01_offset, 2u)), \n      f32(extractBits(b01, b01_offset + 2, 2u)),\n      f32(extractBits(b01, b01_offset + 4, 2u)),\n      f32(extractBits(b01, b01_offset + 6, 2u)));\n  }  \n",3:"\n  let b01 = blocks[src + (row / 2u)];\n  let b2 = blocks[src + 8u + (row / 4u)]; \n\n  let b01_offset_base = (row * 16u) % 32u;\n  let b2_offset_base = (row * 8u) % 32u;\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    let b01_offset = b01_offset_base + (c * 8u);\n    let b2_offset = b2_offset_base + (c * 4u);\n\n    shared_w[dst + c] = vec4(\n      f32(insertBits(extractBits(b01, b01_offset, 2u), extractBits(b2, b2_offset, 1u), 2u, 1u)), \n      f32(insertBits(extractBits(b01, b01_offset + 2, 2u), extractBits(b2, b2_offset + 1, 1u), 2u, 1u)),\n      f32(insertBits(extractBits(b01, b01_offset + 4, 2u), extractBits(b2, b2_offset + 2, 1u), 2u, 1u)),\n      f32(insertBits(extractBits(b01, b01_offset + 6, 2u), extractBits(b2, b2_offset + 3, 1u), 2u, 1u)));    \n  }\n",4:"\n  let b03 = blocks[src + row];\n    \n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    let b03_offset = (c * 16u); \n    shared_w[dst + c] = vec4(\n      f32(extractBits(b03, b03_offset, 4u)), \n      f32(extractBits(b03, b03_offset + 4, 4u)),\n      f32(extractBits(b03, b03_offset + 8, 4u)),\n      f32(extractBits(b03, b03_offset + 12, 4u)));\n  }\n",5:"\n  let b03 = blocks[src + row];\n  let b4 = blocks[src + 16u + (row / 4u)];\n  \n  let b4_offset_base = (row * 8u) % 32u;\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    let b03_offset = (c * 16u);\n    let b4_offset = b4_offset_base + (c * 4u);\n    shared_w[dst + c] = vec4(\n      f32(insertBits(extractBits(b03, b03_offset, 4u), extractBits(b4, b4_offset, 1u), 4u, 1u)), \n      f32(insertBits(extractBits(b03, b03_offset + 4, 4u), extractBits(b4, b4_offset + 1, 1u), 4u, 1u)),\n      f32(insertBits(extractBits(b03, b03_offset + 8, 4u), extractBits(b4, b4_offset + 2, 1u), 4u, 1u)),\n      f32(insertBits(extractBits(b03, b03_offset + 12, 4u), extractBits(b4, b4_offset + 3, 1u), 4u, 1u)));\n  }\n",6:"\n  let b03 = blocks[src + row];\n  let b45 = blocks[src + 16u + (row / 2u)];\n  \n  let b45_offset_base = (row * 16u) % 32u;\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {   \n    let b03_offset = (c * 16u);\n    let b45_offset = b45_offset_base + (c * 8u);\n    shared_w[dst + c] = vec4(\n      f32(insertBits(extractBits(b03, b03_offset, 4u), extractBits(b45, b45_offset, 2u), 4u, 2u)), \n      f32(insertBits(extractBits(b03, b03_offset + 4, 4u), extractBits(b45, b45_offset + 2, 2u), 4u, 2u)),\n      f32(insertBits(extractBits(b03, b03_offset + 8, 4u), extractBits(b45, b45_offset + 4, 2u), 4u, 2u)),\n      f32(insertBits(extractBits(b03, b03_offset + 12, 4u), extractBits(b45, b45_offset + 6, 2u), 4u, 2u)));\n  }\n",7:"\n  let b03 = blocks[src + row];\n  let b45 = blocks[src + 16u + (row / 2u)];\n  let b6 = blocks[src + 24u + (row / 4u)];\n  \n  let b45_offset_base = (row * 16u) % 32u;\n  let b6_offset_base = (row * 8u) % 32u;\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    let b03_offset = (c * 16u);\n    let b45_offset = b45_offset_base + (c * 8u);\n    let b6_offset = b6_offset_base + (c * 4u);\n    \n    shared_w[dst + c] = vec4(\n      f32(insertBits(insertBits(extractBits(b03, b03_offset, 4u), extractBits(b45, b45_offset, 2u), 4u, 2u), extractBits(b6, b6_offset, 1u), 6u, 1u)), \n      f32(insertBits(insertBits(extractBits(b03, b03_offset + 4, 4u), extractBits(b45, b45_offset + 2, 2u), 4u, 2u), extractBits(b6, b6_offset + 1, 1u), 6u, 1u)),\n      f32(insertBits(insertBits(extractBits(b03, b03_offset + 8, 4u), extractBits(b45, b45_offset + 4, 2u), 4u, 2u), extractBits(b6, b6_offset + 2, 1u), 6u, 1u)),\n      f32(insertBits(insertBits(extractBits(b03, b03_offset + 12, 4u), extractBits(b45, b45_offset + 6, 2u), 4u, 2u), extractBits(b6, b6_offset + 3, 1u), 6u, 1u)));\n  }\n",8:"\n  let b07_offset = src + (row * 2);\n  \n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    let b07 = blocks[b07_offset + c];\n    shared_w[dst + c] = vec4(\n      f32(extractBits(b07, 0u, 8u)), \n      f32(extractBits(b07, 8u, 8u)),\n      f32(extractBits(b07, 16u, 8u)),\n      f32(extractBits(b07, 24u, 8u)));\n  }\n"},Ze=function(e){return"\n\n".concat("\nstruct argsStruct {\n  n: u32,\n  m: u32,\n  total_nbc: u32,\n  k: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<f32>;\n","\n\n").concat(Xe,"\n\n").concat("\nvar<workgroup> shared_x: array<vec4<f32>, BN * VEC_COL_PER_BLOCK>;\nvar<workgroup> shared_ab: array<f32, BM * 2>;\nvar<workgroup> shared_w: array<vec4<f32>, BM * ROW_PER_BLOCK * VEC_COL_PER_BLOCK>;\n\nvar<private> local_x: array<vec4<f32>, TN * VEC_COL_PER_BLOCK>;\nvar<private> local_x_sums: array<f32, TN>;\nvar<private> local_results: array<f32, TM * TN>;\n","\n\n").concat(Ke,"\n\n").concat("\n  fn divide_pad(a: u32, b: u32) -> u32 { \n    return (a + b - 1) / b;\n  }\n","\n\nconst bit_depth: u32 = ").concat(e,"u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n \n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(local_invocation_id) local_id: vec3<u32>,\n  @builtin(workgroup_id) workgroup_id: vec3<u32>\n) {\n  ").concat("\n  let tid = local_id.x;\n  let bm_idx = workgroup_id.x;\n  let bn_idx = workgroup_id.y;\n\n  let local_bm_idx = bm_idx * BM;\n  let local_bn_idx = bn_idx * BN;\n  \n  let n_idx = tid % (BN / TN);\n  let k_idx = tid / (BN / TN) / (BM * ROW_PER_BLOCK / TM);\n  let m_idx = tid / (BN / TN) % (BM * ROW_PER_BLOCK / TM);\n","\n    \n  for (var bk_idx = 0u; bk_idx < args.k; bk_idx++) {      \n    ").concat("\n  let total_work_x = VEC_COL_PER_BLOCK * BN;\n  for (var local_idx = 0u; local_idx < divide_pad(total_work_x, TC); local_idx++) {\n    let idx = local_idx * TC + tid;\n    if (idx < total_work_x) {      \n      let n_load_idx = local_bn_idx + idx / VEC_COL_PER_BLOCK;\n      let inner_idx = idx % VEC_COL_PER_BLOCK;\n      \n      if (bk_idx < args.k && n_load_idx < args.n) {  \n        let x_idx = (args.x_offset / 4u) + ((bk_idx * args.n + n_load_idx) * VEC_COL_PER_BLOCK + inner_idx);                                   \n        shared_x[idx] = x[x_idx];\n      } else {\n        shared_x[idx] = vec4(0.0);\n      }\n    }\n  }\n","\n    ").concat("\n  let total_work_ab = BM * 2;\n  for (var local_idx = 0u; local_idx < divide_pad(total_work_ab, TC); local_idx++) {\n    let idx = local_idx * TC + tid;\n    if (idx < total_work_ab) {\n      let m_load_idx = local_bm_idx + idx / 2;      \n      let inner_idx = (idx % 2) * 16u;\n        \n      if (m_load_idx < args.m && bk_idx < args.k) {\n        let ab_bits = extractBits(metas[args.metas_offset + (m_load_idx * args.k + bk_idx)], inner_idx, 16u);\n        shared_ab[idx] = from_fp510(ab_bits);          \n      } else {\n        shared_ab[idx] = 0.0;\n      }\n    }\n  }\n","    \n    ").concat(function(e){return"\n  let total_work_w = BM * ROW_PER_BLOCK;\n  for (var local_idx = 0u; local_idx < divide_pad(total_work_w, TC); local_idx++) {\n    let idx = local_idx * TC + tid;\n    if (idx < total_work_w) {\n      let m_load_idx = local_bm_idx + idx / ROW_PER_BLOCK;\n      let row = idx % ROW_PER_BLOCK;\n      let dst = idx * VEC_COL_PER_BLOCK;\n\n      if (m_load_idx < args.m) {\n        let src = args.blocks_offset + (m_load_idx * args.k + bk_idx) * block_size;\n        ".concat(He[e],"\n      } else {   \n        for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n          shared_w[dst + c] = vec4(0.0);\n        }\n      }\n    }\n  }\n")}(e),"    \n    workgroupBarrier();\n        \n    ").concat("\nfor (var tn_idx = 0u; tn_idx < TN; tn_idx++) {  \n  var x_sum_vec = vec4(0.0);  \n  let local_x_idx = tn_idx * VEC_COL_PER_BLOCK;\n  let shared_x_idx = (n_idx * TN + tn_idx) * VEC_COL_PER_BLOCK + (k_idx * VEC_COL_PER_BLOCK);\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    local_x[local_x_idx + c] = shared_x[shared_x_idx + c];\n    x_sum_vec += local_x[local_x_idx + c];\n  }\n  local_x_sums[tn_idx] = x_sum_vec.x + x_sum_vec.y + x_sum_vec.z + x_sum_vec.w;  \n}\n","\n    ").concat("\n  for (var tm_idx = 0u; tm_idx < TM; tm_idx++) {      \n    let shared_ab_idx = ((m_idx * TM + tm_idx) / ROW_PER_BLOCK + k_idx) * 2;\n    let alpha = shared_ab[shared_ab_idx];\n    let beta = shared_ab[shared_ab_idx + 1];             \n    let shared_w_idx = ((m_idx * TM + tm_idx) + k_idx) * VEC_COL_PER_BLOCK;\n    \n    for (var tn_idx = 0u; tn_idx < TN; tn_idx++) {      \n      let local_x_idx = tn_idx * VEC_COL_PER_BLOCK;\n      \n      var swx_vec = vec4(0.0); \n      for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {        \n        swx_vec += shared_w[shared_w_idx + c] * local_x[local_x_idx + c];\n      }\n      let swx = swx_vec.x + swx_vec.y + swx_vec.z + swx_vec.w;\n      \n      let kappa = alpha * local_x_sums[tn_idx]; \n      let results_idx = tm_idx * TN + tn_idx;\n      local_results[results_idx] += kappa + (beta * swx);\n    }\n  }\n","\n    workgroupBarrier();\n  }\n    \n  ").concat("\nfor (var tm_idx = 0u; tm_idx < TM; tm_idx++) {\n  let row = local_bm_idx * ROW_PER_BLOCK + (m_idx * TM + tm_idx);  \n  for (var tn_idx = 0u; tn_idx < TN; tn_idx++) {    \n    let col = local_bn_idx + (n_idx * TN + tn_idx);\n    if (row < args.m * ROW_PER_BLOCK && col < args.n) {\n      let y_idx = args.y_offset + ((row / ROW_PER_BLOCK) * args.n + col) * ROW_PER_BLOCK + (row % ROW_PER_BLOCK);\n      let results_idx = tm_idx * TN + tn_idx;\n      \n      y[y_idx] += local_results[results_idx];\n    }\n  }\n}\n","\n}\n\n").concat(I,"\n")},Je="\nstruct argsStruct {\n  n: u32,\n  shape1: u32,\n  x_offset: u32,\n  indices_offset: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> indices: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n || global_id.y >= args.shape1) {\n    return;\n  } \n\n  let b = global_id.x;\n  let i = global_id.y;\n      \n  let c = i / 8u;\n  let j = i % 8u;\n  y[((c * args.n) + b) * 8 + j] = x[args.x_offset + (b * args.shape1) + indices[args.indices_offset + i]];\n}\n\n".concat(I,"\n"),$e="\nstruct argsStruct {\n  nvr: u32,\n  nbc: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read_write> y: array<vec4<f32>>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {   \n  if (global_id.x > args.nvr) {\n    return;\n  }\n\n  let x_start = global_id.x * args.nbc;\n  var sum: vec4<f32> = vec4(0.0, 0.0, 0.0, 0.0);\n  for (var i = 0u; i < args.nbc; i++) {\n    sum += x[x_start + i];    \n  }\n  y[global_id.x] += sum;\n}\n\n".concat(I),et="\nstruct argsStruct {\n  n: u32,\n  shape0: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    if (global_id.x >= args.n || global_id.y >= args.shape0) {\n      return;\n    } \n    \n    let b = global_id.x;\n    let i = global_id.y;\n        \n    let r = i / 16u;\n    let j = i % 16u;\n    y[(b * args.shape0) + (r * 16) + j] = x[(((r * args.n) + b) * 16) + j];\n}\n\n".concat(I),tt="\nstruct argsStruct {\n  dimension: u32\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> bias: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> y: array<f32>;\n\n".concat(Ke,"\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {  \n  y[(global_id.x * args.dimension) + global_id.y] += bias[global_id.y];\n}\n\n").concat(I),rt={1:"\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(Ke,"\n\nconst block_size: u32 = 4u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n\n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(8,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n  \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n  \n  let x_start = ((args.x_offset + c) / 4u);\n   \n  var b0_start = row_blocks_start + br_offset + (bc * block_size);\n  var b0_offset = 0u;\n  \n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n  \n  for (var j = 0u; j < ").concat(8,"; j+=4) {\n    \n    var b0 = blocks[b0_start];\n    \n    let w0_0 = f32(extractBits(b0, b0_offset + j, 1u));    \n    let w0_1 = f32(extractBits(b0, b0_offset + j + 1, 1u));    \n    let w0_2 = f32(extractBits(b0, b0_offset + j + 2, 1u));\n    let w0_3 = f32(extractBits(b0, b0_offset + j + 3, 1u));\n        \n    b0_offset = 8u;\n    \n    let w1_0 = f32(extractBits(b0, b0_offset + j, 1u));    \n    let w1_1 = f32(extractBits(b0, b0_offset + j + 1, 1u));    \n    let w1_2 = f32(extractBits(b0, b0_offset + j + 2, 1u));\n    let w1_3 = f32(extractBits(b0, b0_offset + j + 3, 1u));\n        \n    b0_offset = 16u;\n    \n    let w2_0 = f32(extractBits(b0, b0_offset + j, 1u));    \n    let w2_1 = f32(extractBits(b0, b0_offset + j + 1, 1u));    \n    let w2_2 = f32(extractBits(b0, b0_offset + j + 2, 1u));\n    let w2_3 = f32(extractBits(b0, b0_offset + j + 3, 1u));\n        \n    b0_offset = 24u;\n    \n    let w3_0 = f32(extractBits(b0, b0_offset + j, 1u));    \n    let w3_1 = f32(extractBits(b0, b0_offset + j + 1, 1u));    \n    let w3_2 = f32(extractBits(b0, b0_offset + j + 2, 1u));\n    let w3_3 = f32(extractBits(b0, b0_offset + j + 3, 1u));\n    \n    b0_offset = 0u;\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;      \n  }\n  \n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(I),2:"\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(Ke,"\n\nconst block_size: u32 = 8u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n\n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(8,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n  \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n  \n  let x_start = ((args.x_offset + c) / 4u);\n   \n  var b01_start = row_blocks_start + (br_offset * 2u) + (bc * block_size);\n  var b01_offset = 0u;\n  \n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n  \n  for (var j = 0u; j < ").concat(8,"; j+=4) {\n    \n    var b01 = blocks[b01_start];\n    \n    let w0_0 = f32(extractBits(b01, b01_offset + (2u * j), 2u));    \n    let w0_1 = f32(extractBits(b01, b01_offset + (2u * (j + 1)), 2u));    \n    let w0_2 = f32(extractBits(b01, b01_offset + (2u * (j + 2)), 2u));\n    let w0_3 = f32(extractBits(b01, b01_offset + (2u * (j + 3)), 2u));\n        \n    b01_offset = 16u;\n    \n    let w1_0 = f32(extractBits(b01, b01_offset + (2u * j), 2u));    \n    let w1_1 = f32(extractBits(b01, b01_offset + (2u * (j + 1)), 2u));    \n    let w1_2 = f32(extractBits(b01, b01_offset + (2u * (j + 2)), 2u));\n    let w1_3 = f32(extractBits(b01, b01_offset + (2u * (j + 3)), 2u));\n        \n    b01_offset = 0u;    \n    b01 = blocks[b01_start + 1u];\n    \n    let w2_0 = f32(extractBits(b01, b01_offset + (2u * j), 2u));    \n    let w2_1 = f32(extractBits(b01, b01_offset + (2u * (j + 1)), 2u));    \n    let w2_2 = f32(extractBits(b01, b01_offset + (2u * (j + 2)), 2u));\n    let w2_3 = f32(extractBits(b01, b01_offset + (2u * (j + 3)), 2u));\n        \n    b01_offset = 16u;\n    \n    let w3_0 = f32(extractBits(b01, b01_offset + (2u * j), 2u));    \n    let w3_1 = f32(extractBits(b01, b01_offset + (2u * (j + 1)), 2u));    \n    let w3_2 = f32(extractBits(b01, b01_offset + (2u * (j + 2)), 2u));\n    let w3_3 = f32(extractBits(b01, b01_offset + (2u * (j + 3)), 2u));\n    \n    b01_offset = 0u;\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;      \n  }\n  \n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(I),3:"\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(Ke,"\n\nconst block_size: u32 = 12u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n  \n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(8,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n    \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n    \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n\n  let x_start = ((args.x_offset + c) / 4u);\n  \n  var b01_start = row_blocks_start + (br_offset * 2u) + (bc * block_size);\n  var b2_start = row_blocks_start + br_offset + (bc * block_size) + 8u;\n  var b01_offset = 0u;\n  var b2_offset = 0u;\n\n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n  \n  for (var j = 0u; j < ").concat(8,"; j+=4) {    \n         \n    var b01 = blocks[b01_start];\n    var b2 = blocks[b2_start];\n    \n    var b01_bits = extractBits(b01, b01_offset + (2u * j), 2u);\n    var b2_bit = extractBits(b2, b2_offset + j, 1u);\n    let w0_0 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 1)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 1), 1u);\n    let w0_1 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 2)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 2), 1u);\n    let w0_2 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 3)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 3), 1u);\n    let w0_3 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n        \n    b01_offset = 16u;\n    b2_offset = 8u;\n        \n    b01_bits = extractBits(b01, b01_offset + (2u * j), 2u);\n    b2_bit = extractBits(b2, b2_offset + j, 1u);    \n    let w1_0 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 1)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 1), 1u);\n    let w1_1 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 2)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 2), 1u);\n    let w1_2 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 3)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 3), 1u);\n    let w1_3 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n            \n    b01_offset = 0u;\n    b2_offset = 16u;  \n    b01 = blocks[b01_start + 1u];\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * j), 2u);\n    b2_bit = extractBits(b2, b2_offset + j, 1u);    \n    let w2_0 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 1)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 1), 1u);\n    let w2_1 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 2)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 2), 1u);\n    let w2_2 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 3)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 3), 1u);\n    let w2_3 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n        \n    b01_offset = 16u;\n    b2_offset = 24u;      \n    \n    b01_bits = extractBits(b01, b01_offset + (2u * j), 2u);\n    b2_bit = extractBits(b2, b2_offset + j, 1u);    \n    let w3_0 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 1)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 1), 1u);\n    let w3_1 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 2)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 2), 1u);\n    let w3_2 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 3)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 3), 1u);\n    let w3_3 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_offset = 0u;\n    b2_offset = 0u; \n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n      \n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;\n  }\n\n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(I),4:"\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(Ke,"\n\nconst block_size: u32 = 16u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n  \n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(8,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n    \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n \n  let x_start = ((args.x_offset + c) / 4u);\n  \n  var b03_start = row_blocks_start + (br_offset * 4u) + (bc * block_size);    \n\n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n\n  for (var j = 0u; j < ").concat(8,"; j+=4) {\n  \n    var b03 = blocks[b03_start];        \n    \n    let w0_0 = f32(extractBits(b03, 4u * j, 4u));    \n    let w0_1 = f32(extractBits(b03, 4u * (j + 1), 4u));    \n    let w0_2 = f32(extractBits(b03, 4u * (j + 2), 4u));\n    let w0_3 = f32(extractBits(b03, 4u * (j + 3), 4u));\n    \n    b03 = blocks[b03_start + 1];\n    \n    let w1_0 = f32(extractBits(b03, 4u * j, 4u));    \n    let w1_1 = f32(extractBits(b03, 4u * (j + 1), 4u));    \n    let w1_2 = f32(extractBits(b03, 4u * (j + 2), 4u));\n    let w1_3 = f32(extractBits(b03, 4u * (j + 3), 4u));\n    \n    b03 = blocks[b03_start + 2];\n    \n    let w2_0 = f32(extractBits(b03, 4u * j, 4u));    \n    let w2_1 = f32(extractBits(b03, 4u * (j + 1), 4u));    \n    let w2_2 = f32(extractBits(b03, 4u * (j + 2), 4u));\n    let w2_3 = f32(extractBits(b03, 4u * (j + 3), 4u));\n    \n    b03 = blocks[b03_start + 3];\n    \n    let w3_0 = f32(extractBits(b03, 4u * j, 4u));    \n    let w3_1 = f32(extractBits(b03, 4u * (j + 1), 4u));    \n    let w3_2 = f32(extractBits(b03, 4u * (j + 2), 4u));\n    let w3_3 = f32(extractBits(b03, 4u * (j + 3), 4u));\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;\n  }\n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(I),5:"\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(Ke,"\n\nconst block_size: u32 = 20u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n  \n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(8,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n    \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n \n  let x_start = ((args.x_offset + c) / 4u);\n  \n  var b03_start = row_blocks_start + (br_offset * 4u) + (bc * block_size);\n  var b4_start = row_blocks_start + br_offset + (bc * block_size) + 16u;\n  \n  var b4_offset = 0u;\n  \n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n  \n  for (var j = 0u; j < ").concat(8,"; j+=4) {\n  \n    var b03 = blocks[b03_start];\n    var b4 = blocks[b4_start];\n    \n    var b03_bits = extractBits(b03, 4u * j, 4u);\n    var b4_bit = extractBits(b4, b4_offset + j, 1u);    \n    let w0_0 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 1), 1u);\n    let w0_1 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 2), 1u);\n    let w0_2 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 3), 1u);\n    let w0_3 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03 = blocks[b03_start + 1];\n    b4_offset = 8u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b4_bit = extractBits(b4, b4_offset + j, 1u);    \n    let w1_0 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 1), 1u);\n    let w1_1 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 2), 1u);\n    let w1_2 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 3), 1u);\n    let w1_3 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03 = blocks[b03_start + 2];\n    b4_offset = 16u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b4_bit = extractBits(b4, b4_offset + j, 1u);    \n    let w2_0 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 1), 1u);\n    let w2_1 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 2), 1u);\n    let w2_2 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 3), 1u);\n    let w2_3 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03 = blocks[b03_start + 3];\n    b4_offset = 24u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b4_bit = extractBits(b4, b4_offset + j, 1u);    \n    let w3_0 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 1), 1u);\n    let w3_1 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 2), 1u);\n    let w3_2 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 3), 1u);\n    let w3_3 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b4_offset = 0u;\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;\n  }\n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(I),6:"\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(Ke,"\n\nconst block_size: u32 = 24u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n  \n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(8,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n    \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n \n  let x_start = ((args.x_offset + c) / 4u);\n  \n  var b03_start = row_blocks_start + (br_offset * 4u) + (bc * block_size);\n  var b45_start = row_blocks_start + (br_offset * 2u) + (bc * block_size) + 16u;\n  \n  var b45_offset = 0u;\n  \n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n  \n  for (var j = 0u; j < ").concat(8,"; j+=4) {\n  \n    var b03 = blocks[b03_start];\n    var b45 = blocks[b45_start];\n    \n    var b03_bits = extractBits(b03, 4u * j, 4u);\n    var b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    let w0_0 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    let w0_1 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    let w0_2 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    let w0_3 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03 = blocks[b03_start + 1];\n    b45_offset = 16u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    let w1_0 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    let w1_1 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    let w1_2 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    let w1_3 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));  \n    \n    b03 = blocks[b03_start + 2];\n    b45 = blocks[b45_start + 1];\n    b45_offset = 0u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    let w2_0 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    let w2_1 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    let w2_2 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    let w2_3 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03 = blocks[b03_start + 3];\n    b45_offset = 16u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    let w3_0 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    let w3_1 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    let w3_2 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    let w3_3 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b45_offset = 0u;\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;\n  }\n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(I),7:"\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(Ke,"\n\nconst block_size: u32 = 28u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n  \n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(8,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n    \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n \n  let x_start = ((args.x_offset + c) / 4u);\n  \n  var b03_start = row_blocks_start + (br_offset * 4u) + (bc * block_size);\n  var b45_start = row_blocks_start + (br_offset * 2u) + (bc * block_size) + 16u;\n  var b6_start = row_blocks_start + br_offset + (bc * block_size) + 24u;\n  \n  var b45_offset = 0u;\n  var b6_offset = 0u;\n  \n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n  \n  for (var j = 0u; j < ").concat(8,"; j+=4) {\n  \n    var b03 = blocks[b03_start];\n    var b45 = blocks[b45_start];\n    var b6 = blocks[b6_start];\n    \n    var b03_bits = extractBits(b03, 4u * j, 4u);\n    var b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    var b6_bit = extractBits(b6, b6_offset + j, 1u);\n    let w0_0 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 1, 1u);\n    let w0_1 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 2, 1u);\n    let w0_2 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));    \n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 3, 1u);\n    let w0_3 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03 = blocks[b03_start + 1];\n    b45_offset = 16u;\n    b6_offset = 8u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    b6_bit = extractBits(b6, b6_offset + j, 1u);\n    let w1_0 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 1, 1u);\n    let w1_1 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 2, 1u);\n    let w1_2 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));    \n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 3, 1u);\n    let w1_3 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03 = blocks[b03_start + 2];\n    b45 = blocks[b45_start + 1];\n    b45_offset = 0u;\n    b6_offset = 16u;\n\n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    b6_bit = extractBits(b6, b6_offset + j, 1u);\n    let w2_0 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 1, 1u);\n    let w2_1 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 2, 1u);\n    let w2_2 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));    \n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 3, 1u);\n    let w2_3 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03 = blocks[b03_start + 3];\n    b45_offset = 16u;\n    b6_offset = 24u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    b6_bit = extractBits(b6, b6_offset + j, 1u);\n    let w3_0 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 1, 1u);\n    let w3_1 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 2, 1u);\n    let w3_2 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));    \n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 3, 1u);\n    let w3_3 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b45_offset = 0u;\n    b6_offset = 0u;\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;\n  }\n\n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(I),8:"\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(Ke,"\n\nconst block_size: u32 = 32u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n  \n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(8,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n    \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n \n  let x_start = ((args.x_offset + c) / 4u);\n  \n  var b07_start = row_blocks_start + (br_offset * 8u) + (bc * block_size);    \n\n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n\n  for (var j = 0u; j < 2; j++) {\n      \n    var b07 = blocks[b07_start + j];\n    \n    let w0_0 = f32(extractBits(b07, 0u, 8u));    \n    let w0_1 = f32(extractBits(b07, 8u, 8u));    \n    let w0_2 = f32(extractBits(b07, 16u, 8u));\n    let w0_3 = f32(extractBits(b07, 24u, 8u));\n    \n    b07 = blocks[b07_start + 2 + j];\n    \n    let w1_0 = f32(extractBits(b07, 0u, 8u));    \n    let w1_1 = f32(extractBits(b07, 8u, 8u));    \n    let w1_2 = f32(extractBits(b07, 16u, 8u));\n    let w1_3 = f32(extractBits(b07, 24u, 8u));\n    \n    b07 = blocks[b07_start + 4 + j];\n    \n    let w2_0 = f32(extractBits(b07, 0u, 8u));    \n    let w2_1 = f32(extractBits(b07, 8u, 8u));    \n    let w2_2 = f32(extractBits(b07, 16u, 8u));\n    let w2_3 = f32(extractBits(b07, 24u, 8u));\n    \n    b07 = blocks[b07_start + 6 + j];\n    \n    let w3_0 = f32(extractBits(b07, 0u, 8u));    \n    let w3_1 = f32(extractBits(b07, 8u, 8u));    \n    let w3_2 = f32(extractBits(b07, 16u, 8u));\n    let w3_3 = f32(extractBits(b07, 24u, 8u));\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_vec = x[x_start + j];\n    res[j] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;\n  }\n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(I)},nt={1:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_1_shader",2:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_2_shader",3:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_3_shader",4:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_4_shader",5:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_5_shader",6:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_6_shader",7:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_7_shader",8:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_8_shader"},at={1:Ze(1),2:Ze(2),3:Ze(3),4:Ze(4),5:Ze(5),6:Ze(6),7:Ze(7),8:Ze(8)},it={1:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_1_shader",2:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_2_shader",3:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_3_shader",4:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_4_shader",5:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_5_shader",6:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_6_shader",7:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_7_shader",8:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_8_shader"},ut="pv_picollm_weight_block_mixed_16x8_forward_shuffle_x_shader",ot="pv_picollm_weight_block_mixed_16x8_forward_shuffle_y_shader",st="pv_picollm_weight_block_mixed_16x8_add_bias_shader",ct="pv_picollm_weight_block_mixed_16x8_forward_single_reduce_y_shader",lt=function(e,t){var r=e.createBindGroupLayout({label:"weight preprocess blocks ".concat(t," bind group layout"),entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),n=e.createPipelineLayout({label:"weight preprocess blocks ".concat(t," pipeline layout"),bindGroupLayouts:[r]}),a=e.createShaderModule({label:"weight preprocess blocks ".concat(t," shader module"),code:De[t]});return{computePipeline:e.createComputePipeline({label:"weight preprocess blocks ".concat(t," pipeline"),layout:n,compute:{module:a,entryPoint:q,constants:{workgroup_size_x:16,workgroup_size_y:16}}})}},_t=function(e,t){var r=[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}],n=e.createBindGroupLayout({label:"weight forward single ".concat(t," bind group layout"),entries:r}),a=e.createPipelineLayout({label:"weight forward single ".concat(t," pipeline layout"),bindGroupLayouts:[n]}),i=e.createShaderModule({label:"weight forward single ".concat(t," shader module"),code:rt[t]});return{computePipeline:e.createComputePipeline({label:"weight forward single ".concat(t," pipeline"),layout:a,compute:{module:i,entryPoint:q,constants:{workgroup_size_x:256,workgroup_size_y:1}}})}},dt=function(e,t){var r=[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}],n=e.createBindGroupLayout({label:"weight forward multi ".concat(t," bind group layout"),entries:r}),a=e.createPipelineLayout({label:"weight forward multi ".concat(t," pipeline layout"),bindGroupLayouts:[n]}),i=e.createShaderModule({label:"weight forward multi ".concat(t," shader module"),code:at[t]});return{computePipeline:e.createComputePipeline({label:"weight forward multi ".concat(t," pipeline"),layout:a,compute:{module:i,entryPoint:q,constants:{workgroup_size_x:128}}})}},ft=(a(a(a(a(a(a(a(a(a(a(A={},Qe[3],(function(e){return lt(e,3)})),Qe[5],(function(e){return lt(e,5)})),Qe[6],(function(e){return lt(e,6)})),Qe[7],(function(e){return lt(e,7)})),ut,(function(e){var t=e.createBindGroupLayout({label:"weight shuffle x bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"weight shuffle x pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"weight shuffle x shader module",code:Je});return{computePipeline:e.createComputePipeline({label:"weight shuffle x pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_y:N}}})}})),ot,(function(e){var t=e.createBindGroupLayout({label:"weight shuffle y bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"weight shuffle y pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"weight shuffle y shader module",code:et});return{computePipeline:e.createComputePipeline({label:"weight shuffle y pipeline",layout:r,compute:{module:n,entryPoint:q}})}})),ct,(function(e){var t=e.createBindGroupLayout({label:"weight single reduce y bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"weight single reduce y pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"weight single reduce y shader module",code:$e});return{computePipeline:e.createComputePipeline({label:"weight single reduce y pipeline",layout:r,compute:{module:n,entryPoint:q,constants:{workgroup_size_x:N}}})}})),nt[1],(function(e){return _t(e,1)})),nt[2],(function(e){return _t(e,2)})),nt[3],(function(e){return _t(e,3)})),a(a(a(a(a(a(a(a(a(a(A,nt[4],(function(e){return _t(e,4)})),nt[5],(function(e){return _t(e,5)})),nt[6],(function(e){return _t(e,6)})),nt[7],(function(e){return _t(e,7)})),nt[8],(function(e){return _t(e,8)})),it[1],(function(e){return dt(e,1)})),it[2],(function(e){return dt(e,2)})),it[3],(function(e){return dt(e,3)})),it[4],(function(e){return dt(e,4)})),it[5],(function(e){return dt(e,5)})),a(a(a(a(A,it[6],(function(e){return dt(e,6)})),it[7],(function(e){return dt(e,7)})),it[8],(function(e){return dt(e,8)})),st,(function(e){var t=e.createBindGroupLayout({label:"weight add bias bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),r=e.createPipelineLayout({label:"weight add bias pipeline layout",bindGroupLayouts:[t]}),n=e.createShaderModule({label:"weight add bias shader module",code:tt});return{computePipeline:e.createComputePipeline({label:"weight add bias pipeline",layout:r,compute:{module:n,entryPoint:q}})}})));function bt(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function pt(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?bt(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):bt(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}var gt=pt(pt(pt(pt(pt(pt(pt(pt(pt({},oe),ge),ke),Se),Me),Le),Ye),qe),ft);return function(e,r){var n=function(t,r){new Int32Array(e.buffer)[t/Int32Array.BYTES_PER_ELEMENT]=r},a=function(){var e=t(_.mark((function e(t,r){var a,i,u;return _.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(t=C(t),r=C(r),e.prev=2,"undefined"==typeof window||window.isSecureContext){e.next=7;break}return console.error("WebGPU is only available in secure contexts (e.g. HTTPS)"),n(r,-1),e.abrupt("return");case 7:if(navigator.gpu){e.next=11;break}return console.error("WebGPU not supported."),n(r,-1),e.abrupt("return");case 11:return e.next=13,navigator.gpu.requestAdapter();case 13:if(a=e.sent){e.next=18;break}return console.error("WebGPU not supported, please enable it in your browser."),n(r,-1),e.abrupt("return");case 18:return e.next=20,a.requestDevice({requiredFeatures:["timestamp-query"],requiredLimits:{maxBufferSize:1073741824,maxStorageBufferBindingSize:1073741824}});case 20:if(i=e.sent){e.next=25;break}return console.error("Could not find a compatible WebGPU device."),n(r,-1),e.abrupt("return");case 25:return e.next=27,a.requestAdapterInfo();case 27:if(u=e.sent){e.next=32;break}return console.error("Could not retrieve WebGPU adapter info."),n(r,-1),e.abrupt("return");case 32:Y.set(t,new F(i,u)),n(r,0),e.next=40;break;case 36:e.prev=36,e.t0=e.catch(2),console.error(e.t0),n(r,-1);case 40:case"end":return e.stop()}}),e,null,[[2,36]])})));return function(t,r){return e.apply(this,arguments)}}(),i=function(){var r=t(_.mark((function t(r,a,i,u,o,s,l,d,f,b){var p,g,v,x,k,m,h,y,B,P,S,E,U,z,j,M,O,G,T;return _.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(r=C(r),a=C(a),i=C(i),u=C(u),o=C(o),s=C(s),l=C(l),d=C(d),f=C(f),b=C(b),t.prev=10,p=Y.get(r)){t.next=16;break}return console.error("WebGPU device has not been initialized"),n(b,-1),t.abrupt("return");case 16:return g=c.aligned_alloc,v=w.getParser(navigator.userAgent),x=new Uint8Array(e.buffer),k=v.getBrowserName(),t.next=22,g(Uint8Array.BYTES_PER_ELEMENT,(k.length+1)*Uint8Array.BYTES_PER_ELEMENT);case 22:if(0!==(m=t.sent)){t.next=26;break}return n(b,-1),t.abrupt("return");case 26:for(n(a,m),h=0;h<k.length;h++)x[m+h]=k.charCodeAt(h);return x[m+k.length]=0,y=v.getBrowserVersion(),t.next=32,g(Uint8Array.BYTES_PER_ELEMENT,(y.length+1)*Uint8Array.BYTES_PER_ELEMENT);case 32:if(0!==(B=t.sent)){t.next=36;break}return n(b,-1),t.abrupt("return");case 36:for(n(i,B),P=0;P<y.length;P++)x[B+P]=y.charCodeAt(P);return x[B+y.length]=0,S=v.getOSName(),t.next=42,g(Uint8Array.BYTES_PER_ELEMENT,(S.length+1)*Uint8Array.BYTES_PER_ELEMENT);case 42:if(0!==(E=t.sent)){t.next=46;break}return n(b,-1),t.abrupt("return");case 46:for(n(u,E),U=0;U<S.length;U++)x[E+U]=S.charCodeAt(U);return x[E+S.length]=0,z=p.adapterInfo.architecture,t.next=52,g(Uint8Array.BYTES_PER_ELEMENT,(z.length+1)*Uint8Array.BYTES_PER_ELEMENT);case 52:if(0!==(j=t.sent)){t.next=56;break}return n(b,-1),t.abrupt("return");case 56:for(n(o,j),M=0;M<z.length;M++)x[j+M]=z.charCodeAt(M);return x[j+z.length]=0,O=p.adapterInfo.vendor,t.next=62,g(Uint8Array.BYTES_PER_ELEMENT,(O.length+1)*Uint8Array.BYTES_PER_ELEMENT);case 62:if(0!==(G=t.sent)){t.next=66;break}return n(b,-1),t.abrupt("return");case 66:for(n(s,G),T=0;T<O.length;T++)x[G+T]=O.charCodeAt(T);x[G+O.length]=0,n(l,p.device.limits.maxBufferSize),n(d,p.device.limits.maxComputeWorkgroupStorageSize),n(f,p.device.limits.maxComputeInvocationsPerWorkgroup),n(b,0),t.next=79;break;case 75:t.prev=75,t.t0=t.catch(10),console.error(t.t0),n(b,-1);case 79:case"end":return t.stop()}}),t,null,[[10,75]])})));return function(e,t,n,a,i,u,o,s,c,l){return r.apply(this,arguments)}}(),u=function(){var e=t(_.mark((function e(t,r){var a;return _.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(t=C(t),r=C(r),a=Y.get(t)){e.next=6;break}return n(r,-1),e.abrupt("return");case 6:return e.next=8,a.sync();case 8:n(r,0);case 9:case"end":return e.stop()}}),e)})));return function(t,r){return e.apply(this,arguments)}}(),o=function(){var r=t(_.mark((function t(r,n,a,i){var u,o,s,c;return _.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(r=C(r),!((n=C(n))<0)){t.next=5;break}return console.error("Invalid host address",r,n,a,i),t.abrupt("return");case 5:if(null!=(u=W.get(r))&&u.buffer){t.next=9;break}return console.error("GPU buffer has not been allocated"),t.abrupt("return");case 9:if(o=Y.get(u.deviceAddress)){t.next=13;break}return console.error("WebGPU device has not been initialized"),t.abrupt("return");case 13:return s=o.getBuffer((a+i)*Uint8Array.BYTES_PER_ELEMENT,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),o.endComputePass(),o.commandEncoder.copyBufferToBuffer(u.buffer,0,s,0,s.size),t.next=18,o.sync();case 18:return t.next=20,s.mapAsync(GPUMapMode.READ,0,i+a);case 20:c=new Uint8Array(s.getMappedRange(0,i+a)),new Uint8Array(e.buffer).set(c.slice(a,i+a),n),s.unmap(),o.releaseBuffer(s);case 25:case"end":return t.stop()}}),t)})));return function(e,t,n,a){return r.apply(this,arguments)}}(),s=function(){var e=t(_.mark((function e(t){var r;return _.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(t=C(t),r=Y.get(t)){e.next=5;break}return console.error("WebGPU device has not been initialized"),e.abrupt("return");case 5:return e.next=7,r.sync();case 7:r.reportShaderTimes();case 8:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}(),c=pt(pt(pt(pt(pt(pt(pt(pt(pt({aligned_alloc:function(e,t){throw new Error("aligned_alloc was not passed in from parent module")},pv_xpu_webgpu_device_init_wasm:a,pv_xpu_webgpu_device_info_wasm:i,pv_xpu_webgpu_device_cleanup_wasm:function(e){e=C(e),Y.get(e)&&Y.delete(e)},pv_xpu_webgpu_device_load_shader_func_wasm:function(t,r,a){t=C(t),r=C(r),a=C(a);var i=Y.get(t);if(!i)return console.error("WebGPU device has not been initialized"),void n(a,-1);var u=function(e,t){for(var r=t;0!==e[r];)r++;return new TextDecoder("utf-8").decode(e.subarray(t,r))}(new Uint8Array(e.buffer),r);if(!gt[u])return console.error("WebGPU device could not find shader with name ".concat(u)),void n(a,-1);var o=gt[u];i.shaders[u]=o(i.device),n(a,0)},pv_xpu_webgpu_device_wait_wasm:u,pv_xpu_webgpu_device_mem_alloc_wasm:function(e,t,r,a,i){e=C(e),t=C(t),i=C(i);var u=Y.get(e);if(!u)return console.error("WebGPU device has not been initialized"),void n(i,-1);var o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;a&&(o|=GPUBufferUsage.COPY_SRC),W.set(t,{deviceAddress:e,buffer:u.getBuffer(r,o)}),n(i,0)},pv_xpu_webgpu_device_mem_free_wasm:function(e){if(e=C(e),W.has(e)){var t=W.get(e);if(!t||!t.buffer||!t.deviceAddress)return void console.error("GPU buffer has not been allocated");var r=Y.get(t.deviceAddress);if(!r)return void console.error("WebGPU device has not been initialized");r.releaseBuffer(t.buffer),W.delete(e)}},pv_xpu_webgpu_device_mem_copy_to_xpu_wasm:function(t,r,n,a){if(t=C(t),(r=C(r))<0)console.error("Invalid host address",t,r,n,a);else{var i=W.get(t);if(i&&i.buffer&&i.deviceAddress){var u=Y.get(i.deviceAddress);if(u){var o=new Uint8Array(e.buffer);u.writeBuffer(a,n,o.slice(r,r+a),i.buffer)}else console.error("WebGPU device has not been initialized")}else console.error("GPU buffer has not been allocated")}},pv_xpu_webgpu_device_mem_copy_from_xpu_wasm:o,pv_xpu_webgpu_device_mem_memset_wasm:function(e,t,r){e=C(e);var n=W.get(e);if(n&&n.buffer&&n.deviceAddress){var a=Y.get(n.deviceAddress);if(a)if(0===t)a.endComputePass(),a.commandEncoder.clearBuffer(n.buffer,0,r),a.numCommandsEncoded++;else{var i=new Uint8Array(r);i.fill(t),a.writeBuffer(r,0,i,n.buffer)}else console.error("WebGPU device has not been initialized")}else console.error("GPU buffer has not been allocated")},pv_xpu_webgpu_timer_start_wasm:function(e){e=C(e);var t=Y.get(e);t?t.isTimerEnabled=!0:console.error("WebGPU device has not been initialized")},pv_xpu_webgpu_timer_stop_wasm:s},function(e){var t=function(t,r){new Int32Array(e.buffer)[t/Int32Array.BYTES_PER_ELEMENT]=r};return{pv_picollm_attention_precompute_encoding_webgpu_wasm:function(e,r,n,a,i,u,o){var s;e=C(e),r=C(r),o=C(o);var c=Y.get(e);if(!c||!c.device)return console.error("WebGPU device has not been initialized"),void t(o,-1);var l=c.shaders[V];if(!l)return console.error("Shader has not been loaded"),void t(o,-1);var _=null===(s=W.get(r))||void 0===s?void 0:s.buffer;if(!_)return console.error("Encoding buffer has not been allocated"),void t(o,-1);var d=c.getBuffer(4*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"attention precompute encoding arg buffer"),f=new ArrayBuffer(d.size),b=new DataView(f);b.setUint32(0,a,!0),b.setUint32(4,i,!0),b.setFloat32(8,u,!0),b.setUint32(12,n/4,!0),c.device.queue.writeBuffer(d,0,f),c.scheduleUniformBufferForRelease(d);var p=c.device.createBindGroup({label:"attention precompute encoding bind group",layout:l.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:d}},{binding:1,resource:{buffer:_}}]});c.dispatchComputerShader(p,l.computePipeline,V,i),t(o,0)},pv_picollm_attention_encode_webgpu_wasm:function(e,r,n,a,i,u,o,s,c,l,_,d){var f,b;e=C(e),n=C(n),l=C(l),d=C(d);var p=Y.get(e);if(!p||!p.device)return console.error("WebGPU device has not been initialized"),void t(d,-1);var g=r?D:X,v=p.shaders[g];if(!v)return console.error("Shader has not been loaded"),void t(d,-1);var x=null===(f=W.get(l))||void 0===f?void 0:f.buffer;if(!x)return console.error("Encoding buffer has not been allocated"),void t(d,-1);var k=null===(b=W.get(n))||void 0===b?void 0:b.buffer;if(!k)return console.error("X buffer has not been allocated"),void t(d,-1);var m=p.getBuffer(7*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"attention encode arg buffer");p.device.queue.writeBuffer(m,0,new Uint32Array([i,u,o,s,c,_/4,a/4])),p.scheduleUniformBufferForRelease(m);var h=p.device.createBindGroup({label:"attention encode bind group",layout:v.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:m}},{binding:1,resource:{buffer:x}},{binding:2,resource:{buffer:k}}]});p.dispatchComputerShader(h,v.computePipeline,g,Math.min(i,65535),u),t(d,0)},pv_picollm_attention_dot_product_webgpu_wasm:function(e,r,n,a,i,u,o,s,c,l,_,d,f,b,p,g,v,x,k,m,h,y,B){var w,P,S,E,U;e=C(e),r=C(r),a=C(a),u=C(u),s=C(s),h=C(h),B=C(B);var z=Y.get(e);if(!z||!z.device)return console.error("WebGPU device has not been initialized"),void t(B,-1);var j=z.shaders[Z];if(!j)return console.error("Shader has not been loaded"),void t(B,-1);var M=null===(w=W.get(r))||void 0===w?void 0:w.buffer;if(!M)return console.error("query buffer has not been allocated"),void t(B,-1);var O=null===(P=W.get(a))||void 0===P?void 0:P.buffer;if(!O)return console.error("keys buffer has not been allocated"),void t(B,-1);var G=null===(S=W.get(u))||void 0===S?void 0:S.buffer;if(!G)return console.error("key intercepts buffer has not been allocated"),void t(B,-1);var T=null===(E=W.get(s))||void 0===E?void 0:E.buffer;if(!T)return console.error("key slopes buffer has not been allocated"),void t(B,-1);var L=null===(U=W.get(h))||void 0===U?void 0:U.buffer;if(!L)return console.error("scores buffer has not been allocated"),void t(B,-1);var R=z.getBuffer(15*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"attention dot product arg buffer"),A=new ArrayBuffer(R.size),F=new DataView(A);F.setUint32(0,l,!0),F.setUint32(4,_,!0),F.setUint32(8,d,!0),F.setUint32(12,f,!0),F.setUint32(16,b,!0),F.setUint32(20,p,!0),F.setUint32(24,g,!0),F.setFloat32(28,v,!0),F.setUint32(32,x,!0),F.setUint32(36,m,!0),F.setUint32(40,y,!0),F.setUint32(44,n/4,!0),F.setUint32(48,i,!0),F.setUint32(52,o/4,!0),F.setUint32(56,c/4,!0),z.device.queue.writeBuffer(R,0,A),z.scheduleUniformBufferForRelease(R);var N=z.device.createBindGroup({label:"attention dot product bind group",layout:j.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:R}},{binding:1,resource:{buffer:M}},{binding:2,resource:{buffer:O}},{binding:3,resource:{buffer:G}},{binding:4,resource:{buffer:T}},{binding:5,resource:{buffer:L}}]});z.dispatchComputerShader(N,j.computePipeline,Z,f),t(B,0)},pv_picollm_attention_softmax_webgpu_wasm:function(e,r,n,a,i,u){var o;e=C(e),r=C(r),u=C(u);var s=Y.get(e);if(!s||!s.device)return console.error("WebGPU device has not been initialized"),void t(u,-1);var c=s.shaders[$];if(!c)return console.error("Shader has not been loaded"),void t(u,-1);var l=null===(o=W.get(r))||void 0===o?void 0:o.buffer;if(!l)return console.error("Scores buffer has not been allocated"),void t(u,-1);var _=s.getBuffer(3*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"attention softmax arg buffer");s.device.queue.writeBuffer(_,0,new Uint32Array([a,i,n/4])),s.scheduleUniformBufferForRelease(_);var d=s.device.createBindGroup({label:"attention softmax bind group",layout:c.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:_}},{binding:1,resource:{buffer:l}}]});s.dispatchComputerShader(d,c.computePipeline,$,a),t(u,0)},pv_picollm_attention_fir_webgpu_wasm:function(e,r,n,a,i,u,o,s,c,l,_,d,f,b,p,g,v,x,k,m){var h,y,B,w,P;e=C(e),r=C(r),a=C(a),u=C(u),g=C(g),x=C(x),m=C(m);var S=Y.get(e);if(!S||!S.device)return console.error("WebGPU device has not been initialized"),void t(m,-1);var E=S.shaders[te];if(!E)return console.error("Shader has not been loaded"),void t(m,-1);var U=null===(h=W.get(r))||void 0===h?void 0:h.buffer;if(!U)return console.error("values buffer has not been allocated"),void t(m,-1);var z=null===(y=W.get(a))||void 0===y?void 0:y.buffer;if(!z)return console.error("value intercepts buffer has not been allocated"),void t(m,-1);var j=null===(B=W.get(u))||void 0===B?void 0:B.buffer;if(!j)return console.error("value slopes buffer has not been allocated"),void t(m,-1);var M=null===(w=W.get(g))||void 0===w?void 0:w.buffer;if(!M)return console.error("scores buffer has not been allocated"),void t(m,-1);var O=null===(P=W.get(x))||void 0===P?void 0:P.buffer;if(!O)return console.error("output buffer has not been allocated"),void t(m,-1);var G=S.getBuffer(13*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"attention fir arg buffer");S.device.queue.writeBuffer(G,0,new Uint32Array([s,c,l,_,d,f,b,p,n,i/4,o/4,v/4,k/4])),S.scheduleUniformBufferForRelease(G);var T=S.device.createBindGroup({label:"attention fir bind group",layout:E.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:G}},{binding:1,resource:{buffer:U}},{binding:2,resource:{buffer:z}},{binding:3,resource:{buffer:j}},{binding:4,resource:{buffer:M}},{binding:5,resource:{buffer:O}}]});S.dispatchComputerShader(T,E.computePipeline,te,d),t(m,0)},pv_picollm_attention_update_kv_webgpu_wasm:function(e,r,n,a,i,u,o,s,c,l,_,d,f,b,p){var g,v,x,k;e=C(e),r=C(r),i=C(i),o=C(o),c=C(c),p=C(p);var m=Y.get(e);if(!m||!m.device)return console.error("WebGPU device has not been initialized"),void t(p,-1);var h=m.shaders[ne];if(!h)return console.error("Shader has not been loaded"),void t(p,-1);var y=null===(g=W.get(r))||void 0===g?void 0:g.buffer;if(!y)return console.error("tf buffer has not been allocated"),void t(p,-1);var B=null===(v=W.get(i))||void 0===v?void 0:v.buffer;if(!B)return console.error("KV buffer has not been allocated"),void t(p,-1);var w=null===(x=W.get(o))||void 0===x?void 0:x.buffer;if(!w)return console.error("KV intercept buffer has not been allocated"),void t(p,-1);var P=null===(k=W.get(c))||void 0===k?void 0:k.buffer;if(!P)return console.error("KV slopes buffer has not been allocated"),void t(p,-1);var S=m.getBuffer(9*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"attention update kv arg buffer");m.device.queue.writeBuffer(S,0,new Uint32Array([a,_,d,f,b,n/4,u,s/4,l/4])),m.scheduleUniformBufferForRelease(S);var E=m.device.createBindGroup({label:"attention update kv bind group",layout:h.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:S}},{binding:1,resource:{buffer:y}},{binding:2,resource:{buffer:B}},{binding:3,resource:{buffer:w}},{binding:4,resource:{buffer:P}}]});m.dispatchComputerShader(E,h.computePipeline,ne,_),t(p,0)},pv_picollm_attention_transpose_query_webgpu_wasm:function(e,r,n,a,i,u,o,s,c){var l,_;e=C(e),r=C(r),a=C(a),c=C(c);var d=Y.get(e);if(!d||!d.device)return console.error("WebGPU device has not been initialized"),void t(c,-1);var f=d.shaders[ie];if(!f)return console.error("Shader has not been loaded"),void t(c,-1);var b=null===(l=W.get(r))||void 0===l?void 0:l.buffer;if(!b)return console.error("tf buffer has not been allocated"),void t(c,-1);var p=null===(_=W.get(a))||void 0===_?void 0:_.buffer;if(!p)return console.error("hf buffer has not been allocated"),void t(c,-1);var g=d.getBuffer(5*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"attention transpose query arg buffer");d.device.queue.writeBuffer(g,0,new Uint32Array([u,o,s,n/4,i/4])),d.scheduleUniformBufferForRelease(g);var v=d.device.createBindGroup({label:"attention transpose query bind group",layout:f.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:g}},{binding:1,resource:{buffer:b}},{binding:2,resource:{buffer:p}}]});d.dispatchComputerShader(v,f.computePipeline,ie,o,u),t(c,0)}}}(e)),function(e){var t=function(t,r){new Int32Array(e.buffer)[t/Int32Array.BYTES_PER_ELEMENT]=r};return{pv_picollm_gate_forward_webgpu_wasm:function(e,r,n,a,i,u,o,s,c,l,_){var d,f,b;e=C(e),i=C(i),o=C(o),c=C(c),_=C(_);var p=Y.get(e);if(!p||!p.device)return console.error("WebGPU device has not been initialized"),void t(_,-1);var g=p.shaders[ve];if(!g)return console.error("Shader has not been loaded"),void t(_,-1);var v=p.device.createComputePipeline({label:"gate forward pipeline",layout:g.pipelineLayout,compute:{module:g.shaderModule,entryPoint:q,constants:{n:r,k:n,num_experts:a,y_offset:u/4,indices_offset:s/4,weights_offset:l/4}}}),x=null===(d=W.get(i))||void 0===d?void 0:d.buffer;if(!x)return console.error("Y buffer has not been allocated"),void t(_,-1);var k=null===(f=W.get(o))||void 0===f?void 0:f.buffer;if(!k)return console.error("Indices buffer has not been allocated"),void t(_,-1);var m=null===(b=W.get(c))||void 0===b?void 0:b.buffer;if(!m)return console.error("Weights buffer has not been allocated"),void t(_,-1);var h=p.device.createBindGroup({label:"gate forward bind group",layout:v.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:x}},{binding:1,resource:{buffer:k}},{binding:2,resource:{buffer:m}}]});p.dispatchComputerShader(h,v,ve,r),t(_,0)}}}(e)),function(e){var t=function(t,r){new Int32Array(e.buffer)[t/Int32Array.BYTES_PER_ELEMENT]=r};return{pv_picollm_feed_forward_silu_webgpu_wasm:function(e,r,n,a){var i;e=C(e),n=C(n),a=C(a);var u=Y.get(e);if(!u||!u.device)return console.error("WebGPU device has not been initialized"),void t(a,-1);var o=u.shaders[se];if(!o)return console.error("Shader has not been loaded"),void t(a,-1);var s=null===(i=W.get(n))||void 0===i?void 0:i.buffer;if(!s)return console.error("x buffer has not been allocated"),void t(a,-1);var c=u.getBuffer(Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"ff silu arg buffer");u.device.queue.writeBuffer(c,0,new Uint32Array([r])),u.scheduleUniformBufferForRelease(c);var l=u.device.createBindGroup({label:"ff silu bind group",layout:o.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:c}},{binding:1,resource:{buffer:s}}]});u.dispatchComputerShader(l,o.computePipeline,se,Math.ceil(r/N)),t(a,0)},pv_picollm_feed_forward_gelu_webgpu_wasm:function(e,r,n,a){var i;e=C(e),n=C(n),a=C(a);var u=Y.get(e);if(!u||!u.device)return console.error("WebGPU device has not been initialized"),void t(a,-1);var o=u.shaders[le];if(!o)return console.error("Shader has not been loaded"),void t(a,-1);var s=null===(i=W.get(n))||void 0===i?void 0:i.buffer;if(!s)return console.error("x buffer has not been allocated"),void t(a,-1);var c=u.getBuffer(Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"ff gelu arg buffer");u.device.queue.writeBuffer(c,0,new Uint32Array([r])),u.scheduleUniformBufferForRelease(c);var l=u.device.createBindGroup({label:"ff gelu bind group",layout:o.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:c}},{binding:1,resource:{buffer:s}}]});u.dispatchComputerShader(l,o.computePipeline,le,Math.ceil(r/N)),t(a,0)},pv_picollm_feed_forward_almost_gelu_webgpu_wasm:function(e,r,n,a){var i;e=C(e),n=C(n),a=C(a);var u=Y.get(e);if(!u||!u.device)return console.error("WebGPU device has not been initialized"),void t(a,-1);var o=u.shaders[de];if(!o)return console.error("Shader has not been loaded"),void t(a,-1);var s=null===(i=W.get(n))||void 0===i?void 0:i.buffer;if(!s)return console.error("x buffer has not been allocated"),void t(a,-1);var c=u.getBuffer(Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"ff almost gelu arg buffer");u.device.queue.writeBuffer(c,0,new Uint32Array([r])),u.scheduleUniformBufferForRelease(c);var l=u.device.createBindGroup({label:"ff almost gelu bind group",layout:o.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:c}},{binding:1,resource:{buffer:s}}]});u.dispatchComputerShader(l,o.computePipeline,de,Math.ceil(r/N)),t(a,0)},pv_picollm_feed_forward_multiply_buffers_webgpu_wasm:function(e,r,n,a,i){var u,o;e=C(e),n=C(n),a=C(a),i=C(i);var s=Y.get(e);if(!s||!s.device)return console.error("WebGPU device has not been initialized"),void t(i,-1);var c=s.shaders[be];if(!c)return console.error("Shader has not been loaded"),void t(i,-1);var l=null===(u=W.get(n))||void 0===u?void 0:u.buffer;if(!l)return console.error("X buffer has not been allocated"),void t(i,-1);var _=null===(o=W.get(a))||void 0===o?void 0:o.buffer;if(!_)return console.error("Y buffer has not been allocated"),void t(i,-1);var d=s.getBuffer(Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"ff multiply buffers arg buffer");s.device.queue.writeBuffer(d,0,new Uint32Array([r])),s.scheduleUniformBufferForRelease(d);var f=s.device.createBindGroup({label:"ff multiply buffers bind group",layout:c.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:d}},{binding:1,resource:{buffer:l}},{binding:2,resource:{buffer:_}}]});s.dispatchComputerShader(f,c.computePipeline,be,Math.ceil(r/N)),t(i,0)}}}(e)),function(e){var t=function(t,r){new Int32Array(e.buffer)[t/Int32Array.BYTES_PER_ELEMENT]=r};return{pv_picollm_moe_transformer_add_to_buffer_webgpu_wasm:function(e,r,n,a,i,u,o){var s,c;e=C(e),n=C(n),i=C(i),o=C(o);var l=Y.get(e);if(!l||!l.device)return console.error("WebGPU device has not been initialized"),void t(o,-1);var _=l.shaders[me];if(!_)return console.error("Shader has not been loaded"),void t(o,-1);var d=null===(s=W.get(n))||void 0===s?void 0:s.buffer;if(!d)return console.error("x buffer has not been allocated"),void t(o,-1);var f=null===(c=W.get(i))||void 0===c?void 0:c.buffer;if(!f)return console.error("buffer has not been allocated"),void t(o,-1);var b=l.getBuffer(3*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"moe transformer add to buffer arg buffer");l.device.queue.writeBuffer(b,0,new Uint32Array([r,a,u])),l.scheduleUniformBufferForRelease(b);var p=l.device.createBindGroup({label:"moe transformer add to buffer bind group",layout:_.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:b}},{binding:1,resource:{buffer:d}},{binding:2,resource:{buffer:f}}]});l.dispatchComputerShader(p,_.computePipeline,me,r),t(o,0)},pv_picollm_moe_transformer_add_buffers_webgpu_wasm:function(e,r,n,a,i,u,o,s,c){var l,_,d;e=C(e),n=C(n),i=C(i),o=C(o),c=C(c);var f=Y.get(e);if(!f||!f.device)return console.error("WebGPU device has not been initialized"),void t(c,-1);var b=f.shaders[we];if(!b)return console.error("Shader has not been loaded"),void t(c,-1);var p=null===(l=W.get(n))||void 0===l?void 0:l.buffer;if(!p)return console.error("buffer1 has not been allocated"),void t(c,-1);var g=null===(_=W.get(i))||void 0===_?void 0:_.buffer;if(!g)return console.error("buffer2 has not been allocated"),void t(c,-1);var v=null===(d=W.get(o))||void 0===d?void 0:d.buffer;if(!v)return console.error("y has not been allocated"),void t(c,-1);var x=f.getBuffer(4*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"moe transformer add buffers arg buffer");f.device.queue.writeBuffer(x,0,new Uint32Array([r,a,u,s])),f.scheduleUniformBufferForRelease(x);var k=f.device.createBindGroup({label:"moe transformer add buffers bind group",layout:b.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:x}},{binding:1,resource:{buffer:p}},{binding:2,resource:{buffer:g}},{binding:3,resource:{buffer:v}}]});f.dispatchComputerShader(k,b.computePipeline,we,r),t(c,0)},pv_picollm_moe_transformer_multiply_weight_and_add_to_buffer_webgpu_wasm:function(e,r,n,a,i,u,o,s,c,l,_){var d,f,b;e=C(e),i=C(i),o=C(o),c=C(c),_=C(_);var p=Y.get(e);if(!p||!p.device)return console.error("WebGPU device has not been initialized"),void t(_,-1);var g=p.shaders[ye];if(!g)return console.error("Shader has not been loaded"),void t(_,-1);var v=null===(d=W.get(i))||void 0===d?void 0:d.buffer;if(!v)return console.error("weights has not been allocated"),void t(_,-1);var x=null===(f=W.get(o))||void 0===f?void 0:f.buffer;if(!x)return console.error("buffer2 has not been allocated"),void t(_,-1);var k=null===(b=W.get(c))||void 0===b?void 0:b.buffer;if(!k)return console.error("y has not been allocated"),void t(_,-1);var m=p.getBuffer(6*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"moe transformer multiply weight and add to buffer arg buffer");p.device.queue.writeBuffer(m,0,new Uint32Array([r,n,a,u,s,l])),p.scheduleUniformBufferForRelease(m);var h=p.device.createBindGroup({label:"moe transformer multiply weight and add to buffer bind group",layout:g.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:m}},{binding:1,resource:{buffer:v}},{binding:2,resource:{buffer:x}},{binding:3,resource:{buffer:k}}]});p.dispatchComputerShader(h,g.computePipeline,ye,r),t(_,0)}}}(e)),function(e){var t=function(t,r){new Int32Array(e.buffer)[t/Int32Array.BYTES_PER_ELEMENT]=r};return{pv_picollm_norm_layer_forward_webgpu_wasm:function(e,r,n,a,i,u,o,s,c,l,_,d,f){var b,p,g;e=C(e),a=C(a),u=C(u),c=C(c),_=C(_),f=C(f);var v=Y.get(e);if(!v||!v.device)return console.error("WebGPU device has not been initialized"),void t(f,-1);var x=c===_?Ge:Ce,k=v.shaders[x];if(!k)return console.error("Shader has not been loaded"),void t(f,-1);var m=null===(b=W.get(a))||void 0===b?void 0:b.buffer;if(!m)return console.error("weight buffer has not been allocated"),void t(f,-1);var h=null===(p=W.get(u))||void 0===p?void 0:p.buffer;if(!h)return console.error("bias buffer has not been allocated"),void t(f,-1);var y=null===(g=W.get(_))||void 0===g?void 0:g.buffer;if(!y)return console.error("Y buffer has not been allocated"),void t(f,-1);var B,w=v.getBuffer(7*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"norm layer forward multi buffer arg buffer"),P=new ArrayBuffer(w.size),S=new DataView(P);if(S.setUint32(0,s,!0),S.setUint32(4,r,!0),S.setFloat32(8,n,!0),S.setUint32(12,i/4,!0),S.setUint32(16,o/4,!0),S.setUint32(20,l/4,!0),S.setUint32(24,d/4,!0),v.device.queue.writeBuffer(w,0,P),v.scheduleUniformBufferForRelease(w),c===_)B=v.device.createBindGroup({label:"norm layer forward single buffer bind group",layout:k.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:w}},{binding:1,resource:{buffer:m}},{binding:2,resource:{buffer:h}},{binding:3,resource:{buffer:y}}]});else{var E,U=null===(E=W.get(c))||void 0===E?void 0:E.buffer;if(!U)return console.error("X buffer has not been allocated"),void t(f,-1);B=v.device.createBindGroup({label:"norm layer forward multi buffer bind group",layout:k.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:w}},{binding:1,resource:{buffer:m}},{binding:2,resource:{buffer:h}},{binding:3,resource:{buffer:U}},{binding:4,resource:{buffer:y}}]})}v.dispatchComputerShader(B,k.computePipeline,x,Math.ceil(s/N)),t(f,0)}}}(e)),function(e){var t=function(t,r){new Int32Array(e.buffer)[t/Int32Array.BYTES_PER_ELEMENT]=r};return{pv_picollm_norm_forward_webgpu_wasm:function(e,r,n,a,i,u,o,s,c,l){var _,d;e=C(e),a=C(a),o=C(o),c=C(c),l=C(l);var f=Y.get(e);if(!f||!f.device)return console.error("WebGPU device has not been initialized"),void t(l,-1);var b=o===c?Ue:Ee,p=f.shaders[b];if(!p)return console.error("Shader has not been loaded"),void t(l,-1);var g=null===(_=W.get(a))||void 0===_?void 0:_.buffer;if(!g)return console.error("Weight buffer has not been allocated"),void t(l,-1);var v=null===(d=W.get(c))||void 0===d?void 0:d.buffer;if(!v)return console.error("Y buffer has not been allocated"),void t(l,-1);var x=r%4,k=r-x,m=f.getBuffer(7*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"norm forward multi buffer arg buffer"),h=new ArrayBuffer(m.size),y=new DataView(h);y.setUint32(0,i,!0),y.setUint32(4,r,!0),y.setUint32(8,x,!0),y.setUint32(12,k,!0),y.setFloat32(16,n,!0),y.setUint32(20,u/4,!0),y.setUint32(24,s/4,!0),f.device.queue.writeBuffer(m,0,h),f.scheduleUniformBufferForRelease(m);var B=[{binding:0,resource:{buffer:m}},{binding:1,resource:{buffer:g}}];if(o===c)B.push({binding:2,resource:{buffer:v}});else{var w,P=null===(w=W.get(o))||void 0===w?void 0:w.buffer;if(!P)return console.error("X buffer has not been allocated"),void t(l,-1);B.push({binding:2,resource:{buffer:P}}),B.push({binding:3,resource:{buffer:v}})}var S=f.device.createBindGroup({label:"norm forward ".concat(o===c?"single":"multi"," buffer bind group"),layout:p.computePipeline.getBindGroupLayout(0),entries:B});f.dispatchComputerShader(S,p.computePipeline,b,i),t(l,0)}}}(e)),function(e){var t=function(t,r){new Int32Array(e.buffer)[t/Int32Array.BYTES_PER_ELEMENT]=r};return{pv_picollm_transformer_add_to_buffer_webgpu_wasm:function(e,r,n,a,i,u,o){var s,c;e=C(e),n=C(n),i=C(i),o=C(o);var l=Y.get(e);if(!l||!l.device)return console.error("WebGPU device has not been initialized"),void t(o,-1);var _=l.shaders[Re];if(!_)return console.error("Shader has not been loaded"),void t(o,-1);var d=null===(s=W.get(n))||void 0===s?void 0:s.buffer;if(!d)return console.error("x buffer has not been allocated"),void t(o,-1);var f=null===(c=W.get(i))||void 0===c?void 0:c.buffer;if(!f)return console.error("buffer has not been allocated"),void t(o,-1);var b=l.getBuffer(3*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"transformer add to buffer arg buffer");l.device.queue.writeBuffer(b,0,new Uint32Array([r,a,u])),l.scheduleUniformBufferForRelease(b);var p=l.device.createBindGroup({label:"transformer add to buffer bind group",layout:_.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:b}},{binding:1,resource:{buffer:d}},{binding:2,resource:{buffer:f}}]});l.dispatchComputerShader(p,_.computePipeline,Re,Math.ceil(r/N)),t(o,0)},pv_picollm_transformer_add_buffers_webgpu_wasm:function(e,r,n,a,i,u,o,s,c){var l,_,d;e=C(e),n=C(n),i=C(i),o=C(o),c=C(c);var f=Y.get(e);if(!f||!f.device)return console.error("WebGPU device has not been initialized"),void t(c,-1);var b=f.shaders[Fe];if(!b)return console.error("Shader has not been loaded"),void t(c,-1);var p=null===(l=W.get(n))||void 0===l?void 0:l.buffer;if(!p)return console.error("buffer1 has not been allocated"),void t(c,-1);var g=null===(_=W.get(i))||void 0===_?void 0:_.buffer;if(!g)return console.error("buffer2 has not been allocated"),void t(c,-1);var v=null===(d=W.get(o))||void 0===d?void 0:d.buffer;if(!v)return console.error("y has not been allocated"),void t(c,-1);var x=f.getBuffer(4*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"transformer add buffers arg buffer");f.device.queue.writeBuffer(x,0,new Uint32Array([r,a,u,s])),f.scheduleUniformBufferForRelease(x);var k=f.device.createBindGroup({label:"transformer add buffers bind group",layout:b.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:x}},{binding:1,resource:{buffer:p}},{binding:2,resource:{buffer:g}},{binding:3,resource:{buffer:v}}]});f.dispatchComputerShader(k,b.computePipeline,Fe,Math.ceil(r/N)),t(c,0)}}}(e)),function(e){var t=function(t,r){new Int32Array(e.buffer)[t/Int32Array.BYTES_PER_ELEMENT]=r};return{pv_picollm_weight_float_forward_webgpu_wasm:function(e,r,n,a,i,u,o,s,c,l,_){var d,f,b;e=C(e),u=C(u),s=C(s),l=C(l),_=C(_);var p=Y.get(e);if(!p||!p.device)return console.error("WebGPU device has not been initialized"),void t(_,-1);var g=p.shaders[We];if(!g)return console.error("Shader has not been loaded"),void t(_,-1);var v=null===(d=W.get(u))||void 0===d?void 0:d.buffer;if(!v)return console.error("W buffer has not been allocated"),void t(_,-1);var x=null===(f=W.get(s))||void 0===f?void 0:f.buffer;if(!x)return console.error("X buffer has not been allocated"),void t(_,-1);var k=null===(b=W.get(l))||void 0===b?void 0:b.buffer;if(!k)return console.error("Y buffer has not been allocated"),void t(_,-1);var m=p.getBuffer(5*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"weight float forward arg buffer");p.device.queue.writeBuffer(m,0,new Uint32Array([a,n,i,o,c])),p.scheduleUniformBufferForRelease(m);var h=p.device.createBindGroup({label:"weight float forward bind group",layout:g.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:m}},{binding:1,resource:{buffer:v}},{binding:2,resource:{buffer:x}},{binding:3,resource:{buffer:k}}]});p.dispatchComputerShader(h,g.computePipeline,We,r),t(_,0)}}}(e)),function(e){var t=function(t,r){new Int32Array(e.buffer)[t/Int32Array.BYTES_PER_ELEMENT]=r};return{pv_picollm_weight_block_mixed_16x8_preprocess_blocks_webgpu_wasm:function(e,r,n,a,i,u,o){var s;e=C(e),n=C(n),o=C(o);var c=Y.get(e);if(!c||!c.device)return console.error("WebGPU device has not been initialized"),void t(o,-1);var l=c.shaders[Qe[r]];if(!l)return console.error("Shader has not been loaded"),void t(o,-1);var _=null===(s=W.get(n))||void 0===s?void 0:s.buffer;if(!_)return console.error("blocks buffer has not been allocated"),void t(o,-1);var d=c.getBuffer(3*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"weight preprocess blocks ".concat(r," arg buffer"));c.device.queue.writeBuffer(d,0,new Uint32Array([i,u,a/4])),c.scheduleUniformBufferForRelease(d);var f=c.device.createBindGroup({label:"weight preprocess blocks ".concat(r," bind group"),layout:l.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:d}},{binding:1,resource:{buffer:_}}]});c.dispatchComputerShader(f,l.computePipeline,Qe[r],Math.ceil(i/16),Math.ceil(u/16)),t(o,0)},pv_picollm_weight_block_mixed_16x8_forward_single_shuffle_x_webgpu_wasm:function(e,r,n,a,i,u,o,s){var c,l,_;e=C(e),r=C(r),a=C(a),o=C(o),s=C(s);var d=Y.get(e);if(!d||!d.device)return console.error("WebGPU device has not been initialized"),void t(s,-1);var f=d.shaders[ut];if(!f)return console.error("Shader has not been loaded"),void t(s,-1);var b=null===(c=W.get(r))||void 0===c?void 0:c.buffer;if(!b)return console.error("X buffer has not been allocated"),void t(s,-1);var p=null===(l=W.get(a))||void 0===l?void 0:l.buffer;if(!p)return console.error("Indices buffer has not been allocated"),void t(s,-1);var g=null===(_=W.get(o))||void 0===_?void 0:_.buffer;if(!g)return console.error("Y buffer has not been allocated"),void t(s,-1);var v=d.getBuffer(4*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"weight shuffle x arg buffer");d.device.queue.writeBuffer(v,0,new Uint32Array([1,u,n/4,i/4])),d.scheduleUniformBufferForRelease(v);var x=d.device.createBindGroup({label:"weight forward single shuffle x bind group",layout:f.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:v}},{binding:1,resource:{buffer:b}},{binding:2,resource:{buffer:p}},{binding:3,resource:{buffer:g}}]});d.dispatchComputerShader(x,f.computePipeline,ut+"_single",1,Math.ceil(u/N)),t(s,0)},pv_picollm_weight_block_mixed_16x8_forward_single_webgpu_wasm:function(e,r,n,a,i,u,o,s,c,l,_,d,f,b){var p,g,v,x;e=C(e),n=C(n),i=C(i),o=C(o),d=C(d),b=C(b);var k=Y.get(e);if(!k||!k.device)return console.error("WebGPU device has not been initialized"),void t(b,-1);var m=k.shaders[nt[r]];if(!m)return console.error("Shader has not been loaded"),void t(b,-1);var h=null===(p=W.get(n))||void 0===p?void 0:p.buffer;if(!h)return console.error("X buffer has not been allocated"),void t(b,-1);var y=null===(g=W.get(i))||void 0===g?void 0:g.buffer;if(!y)return console.error("Metas buffer has not been allocated"),void t(b,-1);var B=null===(v=W.get(o))||void 0===v?void 0:v.buffer;if(!B)return console.error("Blocks buffer has not been allocated"),void t(b,-1);var w=null===(x=W.get(d))||void 0===x?void 0:x.buffer;if(!w)return console.error("Y buffer has not been allocated"),void t(b,-1);var P=k.getBuffer(8*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"weight forward single ".concat(r," arg buffer"));k.device.queue.writeBuffer(P,0,new Uint32Array([1,c,l,_,a/4,u/4,s/4,f/4])),k.scheduleUniformBufferForRelease(P);var S=[{binding:0,resource:{buffer:P}},{binding:1,resource:{buffer:h}},{binding:2,resource:{buffer:y}},{binding:3,resource:{buffer:B}},{binding:4,resource:{buffer:w}}],E=k.device.createBindGroup({label:"weight forward single ".concat(r," bind group"),layout:m.computePipeline.getBindGroupLayout(0),entries:S});k.dispatchComputerShader(E,m.computePipeline,nt[r],Math.ceil(4*c/256),_),t(b,0)},pv_picollm_weight_block_mixed_16x8_forward_single_reduce_y_webgpu_wasm:function(e,r,n,a,i,u){var o,s;e=C(e),a=C(a),i=C(i),u=C(u);var c=Y.get(e);if(!c||!c.device)return console.error("WebGPU device has not been initialized"),void t(u,-1);var l=c.shaders[ct];if(!l)return console.error("Shader has not been loaded"),void t(u,-1);var _=null===(o=W.get(a))||void 0===o?void 0:o.buffer;if(!_)return console.error("X buffer has not been allocated"),void t(u,-1);var d=null===(s=W.get(i))||void 0===s?void 0:s.buffer;if(!d)return console.error("Y buffer has not been allocated"),void t(u,-1);var f=c.getBuffer(2*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"weight single reduce y arg buffer");c.device.queue.writeBuffer(f,0,new Uint32Array([4*r,n])),c.scheduleUniformBufferForRelease(f);var b=c.device.createBindGroup({label:"weight forward single reduce y bind group",layout:l.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:_}},{binding:2,resource:{buffer:d}}]});c.dispatchComputerShader(b,l.computePipeline,ct,Math.ceil(4*r/256)),t(u,0)},pv_picollm_weight_block_mixed_16x8_forward_multiple_shuffle_x_webgpu_wasm:function(e,r,n,a,i,u,o,s,c){var l,_,d;e=C(e),r=C(r),a=C(a),s=C(s),c=C(c);var f=Y.get(e);if(!f||!f.device)return console.error("WebGPU device has not been initialized"),void t(c,-1);var b=f.shaders[ut];if(!b)return console.error("Shader has not been loaded"),void t(c,-1);var p=null===(l=W.get(r))||void 0===l?void 0:l.buffer;if(!p)return console.error("X buffer has not been allocated"),void t(c,-1);var g=null===(_=W.get(a))||void 0===_?void 0:_.buffer;if(!g)return console.error("Indices buffer has not been allocated"),void t(c,-1);var v=null===(d=W.get(s))||void 0===d?void 0:d.buffer;if(!v)return console.error("Y buffer has not been allocated"),void t(c,-1);var x=f.getBuffer(4*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"weight multi shuffle x arg buffer");f.device.queue.writeBuffer(x,0,new Uint32Array([u,o,n/4,i/4])),f.scheduleUniformBufferForRelease(x);var k=f.device.createBindGroup({label:"weight forward multiple shuffle x bind group",layout:b.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:x}},{binding:1,resource:{buffer:p}},{binding:2,resource:{buffer:g}},{binding:3,resource:{buffer:v}}]});f.dispatchComputerShader(k,b.computePipeline,ut+"_multi",u,o),t(c,0)},pv_picollm_weight_block_mixed_16x8_forward_multiple_webgpu_wasm:function(e,r,n,a,i,u,o,s,c,l,_,d,f,b){var p,g,v,x;e=C(e),n=C(n),i=C(i),o=C(o),d=C(d),b=C(b);var k=Y.get(e);if(!k||!k.device)return console.error("WebGPU device has not been initialized"),void t(b,-1);var m=k.shaders[it[r]];if(!m)return console.error("Shader has not been loaded"),void t(b,-1);var h=null===(p=W.get(n))||void 0===p?void 0:p.buffer;if(!h)return console.error("X buffer has not been allocated"),void t(b,-1);var y=null===(g=W.get(i))||void 0===g?void 0:g.buffer;if(!y)return console.error("Metas buffer has not been allocated"),void t(b,-1);var B=null===(v=W.get(o))||void 0===v?void 0:v.buffer;if(!B)return console.error("Blocks buffer has not been allocated"),void t(b,-1);var w=null===(x=W.get(d))||void 0===x?void 0:x.buffer;if(!w)return console.error("Y buffer has not been allocated"),void t(b,-1);var P=k.getBuffer(8*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"weight forward multi ".concat(r," arg buffer"));k.device.queue.writeBuffer(P,0,new Uint32Array([_,l,0,c,a/4,u/4,s/4,f/4])),k.scheduleUniformBufferForRelease(P);var S=[{binding:0,resource:{buffer:P}},{binding:1,resource:{buffer:h}},{binding:2,resource:{buffer:y}},{binding:3,resource:{buffer:B}},{binding:4,resource:{buffer:w}}],E=k.device.createBindGroup({label:"weight forward multi ".concat(r," bind group"),layout:m.computePipeline.getBindGroupLayout(0),entries:S});k.dispatchComputerShader(E,m.computePipeline,it[r],Math.ceil(l/8),Math.ceil(_/32)),t(b,0)},pv_picollm_weight_block_mixed_16x8_forward_multiple_shuffle_y_webgpu_wasm:function(e,r,n,a,i,u){var o,s;e=C(e),a=C(a),i=C(i),u=C(u);var c=Y.get(e);if(!c||!c.device)return console.error("WebGPU device has not been initialized"),void t(u,-1);var l=c.shaders[ot];if(!l)return console.error("Shader has not been loaded"),void t(u,-1);var _=null===(o=W.get(a))||void 0===o?void 0:o.buffer;if(!_)return console.error("X buffer has not been allocated"),void t(u,-1);var d=null===(s=W.get(i))||void 0===s?void 0:s.buffer;if(!d)return console.error("Y buffer has not been allocated"),void t(u,-1);var f=c.getBuffer(2*Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"weight shuffle y arg buffer");c.device.queue.writeBuffer(f,0,new Uint32Array([r,n])),c.scheduleUniformBufferForRelease(f);var b=c.device.createBindGroup({label:"weight forward multiple shuffle y bind group",layout:l.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:_}},{binding:2,resource:{buffer:d}}]});c.dispatchComputerShader(b,l.computePipeline,ot,r,n),t(u,0)},pv_picollm_weight_block_mixed_16x8_add_bias_webgpu_wasm:function(e,r,n,a,i,u){var o,s;e=C(e),a=C(a),i=C(i),u=C(u);var c=Y.get(e);if(!c||!c.device)return console.error("WebGPU device has not been initialized"),void t(u,-1);var l=c.shaders[st];if(!l)return console.error("Shader has not been loaded"),void t(u,-1);var _=null===(o=W.get(a))||void 0===o?void 0:o.buffer;if(!_)return console.error("Bias buffer has not been allocated"),void t(u,-1);var d=null===(s=W.get(i))||void 0===s?void 0:s.buffer;if(!d)return console.error("Y buffer has not been allocated"),void t(u,-1);var f=c.getBuffer(Uint32Array.BYTES_PER_ELEMENT,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,!1,"weight add bias arg buffer");c.device.queue.writeBuffer(f,0,new Uint32Array([n])),c.scheduleUniformBufferForRelease(f);var b=c.device.createBindGroup({label:"weight add bias bind group",layout:l.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:_}},{binding:2,resource:{buffer:d}}]});c.dispatchComputerShader(b,l.computePipeline,st,r,n),t(u,0)}}}(e));return c}}();
